<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conquering-Errors-in-Go-A-Guide-to-Returning-and-Handling-errors</title>
    <link rel="stylesheet" href="https://c1312.netlify.app/typo.css">
    <link rel="stylesheet" href="https://c1312.netlify.app/style.css">
</head>
<body>
<header>
  <h1>Conquering-Errors-in-Go-A-Guide-to-Returning-and-Handling-errors</h1>
</header>
<main class="typo"><div><h1>Level 1: if err != nil</h1><p>This is the most simple method of returning error. Most of us are familiar with this pattern. You call a function that might return an error, check if the error is nil, if it isn’t return the error<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>import</span> (<br> <span>&#34;errors&#34;</span><br> <span>&#34;fmt&#34;</span><br>)<br><br><span><span>func</span> <span>doSomething</span><span>()</span></span> (<span>float64</span>, <span>error</span>) {<br> result, err := mayReturnError();<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, err<br> }<br> <span>return</span> result, <span>nil</span><br>}</span></pre><h2>Problems with this approach</h2><p>While this maybe the simplest and infact the most used method it suffers from a major problem: <strong>lack of context</strong>. If you have a deep call stack you don’t know which function caused the error.<p>Imagine you have a call stack where function A() calls B(), B() calls C() and C() returns an error which looks like this:<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>package</span> main<br><br><span>import</span> (<br> <span>&#34;errors&#34;</span><br> <span>&#34;fmt&#34;</span><br>)<br><br><span><span>func</span> <span>A</span><span>(x <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> result, err := B(x)<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, err<br> }<br> <span>return</span> result * <span>3</span>, <span>nil</span><br>}<br><br><span><span>func</span> <span>B</span><span>(x <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> result, err := C(x)<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, err<br> }<br> <span>return</span> result + <span>2</span>, <span>nil</span><br>}<br><br><span><span>func</span> <span>C</span><span>(x <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> <span>if</span> x &lt; <span>0</span> {<br>  <span>return</span> <span>0</span>, errors.New(<span>&#34;negative value not allowed&#34;</span>)<br> }<br> <span>return</span> x * x, <span>nil</span><br>}<br><br><span><span>func</span> <span>main</span><span>()</span></span> {<br> <span>// Call function A with invalid input</span><br> result, err := A(<span>-2</span>)<br> <span>if</span> err == <span>nil</span> {<br>  fmt.Println(<span>&#34;Result:&#34;</span>, result)<br> } <span>else</span> {<br>  fmt.Println(<span>&#34;Error:&#34;</span>, err)<br> }<br>}</span></pre><p>If you run this program it will output the following<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span>Error: negative value not allowed</span></pre><p>We have no context in the error message itself as to where this error occured in the call stack. We have to open the program in code editor and search for the specific error string to find where the error could have been originating from.<h1>Level 2: Wrapped Errors</h1><p>To add context to the errors we will wrap the errors using <code class="cw qd qe qf oz b">fmt.Errorf</code> .<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>package</span> main<br><br><span>import</span> (<br> <span>&#34;errors&#34;</span><br> <span>&#34;fmt&#34;</span><br>)<br><br><span><span>func</span> <span>A</span><span>(x <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> result, err := B(x)<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;A: %w&#34;</span>, err)<br> }<br> <span>return</span> result * <span>3</span>, <span>nil</span><br>}<br><br><span><span>func</span> <span>B</span><span>(x <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> result, err := C(x)<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;B: %w&#34;</span>, err)<br> }<br> <span>return</span> result + <span>2</span>, <span>nil</span><br>}<br><br><span><span>func</span> <span>C</span><span>(x <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> <span>if</span> x &lt; <span>0</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;C: %w&#34;</span>, errors.New(<span>&#34;negative value not allowed&#34;</span>))<br> }<br> <span>return</span> x * x, <span>nil</span><br>}<br><br><span><span>func</span> <span>main</span><span>()</span></span> {<br> <span>// Call function A with invalid input</span><br> result, err := A(<span>-2</span>)<br> <span>if</span> err == <span>nil</span> {<br>  fmt.Println(<span>&#34;Result:&#34;</span>, result)<br> } <span>else</span> {<br>  fmt.Println(<span>&#34;Error:&#34;</span>, err)<br> }<br>}</span></pre><p>if we run this program we will get the following output<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span>Error: A: B: C: negative value not allowed</span></pre><p>Now we understand the call stack.<p>However it still has a problem.<h2>Problems with this approach</h2><p>We now know where the error has occurred but we still don’t know <strong>what has gone wrong.</strong><h1>Level 3: Descriptive Errors</h1><p>The error isn’t descriptive enough. To demonstrate this we need a slightly more complex example.<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>import</span> (<br> <span>&#34;errors&#34;</span><br> <span>&#34;fmt&#34;</span><br>)<br><br><span><span>func</span> <span>DoSomething</span><span>()</span></span> (<span>int</span>, <span>error</span>) {<br> result, err := DoSomethingElseWithTwoSteps()<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;DoSomething: %w&#34;</span>, err)<br> }<br> <span>return</span> result * <span>3</span>, <span>nil</span><br>}<br><br><span><span>func</span> <span>DoSomethingElseWithTwoSteps</span><span>()</span></span> (<span>int</span>, <span>error</span>) {<br> stepOne, err := StepOne()<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;DoSomethingElseWithTwoSteps:%w&#34;</span>, err)<br> }<br><br> stepTwo, err := StepTwo()<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;DoSomethingElseWithTwoSteps: %w&#34;</span>, err)<br> }<br><br> <span>return</span> stepOne + StepTwo, <span>nil</span><br>}</span></pre><p>In this example, if an error is returned we don’t know which operation in particular has failed, <code class="cw qd qe qf oz b">StepOne</code> or <code class="cw qd qe qf oz b">StepTwo</code>. We will get the same error saying <code class="cw qd qe qf oz b">Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError</code><p>To fix that we need to add context of what specifically has gone wrong<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>import</span> (<br> <span>&#34;errors&#34;</span><br> <span>&#34;fmt&#34;</span><br>)<br><br><span><span>func</span> <span>DoSomething</span><span>()</span></span> (<span>int</span>, <span>error</span>) {<br> result, err := DoSomethingElseWithTwoSteps()<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;DoSomething: %w&#34;</span>, err)<br> }<br> <span>return</span> result * <span>3</span>, <span>nil</span><br>}<br><br><span><span>func</span> <span>DoSomethingElseWithTwoSteps</span><span>()</span></span> (<span>int</span>, <span>error</span>) {<br> stepOne, err := StepOne()<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;DoSomethingElseWithTwoSteps: StepOne: %w&#34;</span>, err)<br> }<br><br> stepTwo, err := StepTwo()<br> <span>if</span> err != <span>nil</span> {<br>  <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;DoSomethingElseWithTwoSteps: StepTwo: %w&#34;</span>, err)<br> }<br><br> <span>return</span> stepOne + StepTwo, <span>nil</span><br>}</span></pre><p>So now if <code class="cw qd qe qf oz b">StepOne</code> fails we will get <code class="cw qd qe qf oz b">Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError</code><h2>Problems with this approach</h2><p>The error now expresses the call stack using function names. But it does not express the nature of the error. Errors should tell a story.<p>A good example is HTTP status code. If you receive a 404 you know the resource you were trying to get doesn’t exist.<h1>Level 4: Error Sentinels</h1><p>Error sentinels are predefined error constants that can be reused.<p>There can be various causes a function can fail but I like to broadly put it into 4 categories. Not Found Error, Already Exists Error, Failed Precondition error and Internal Error. These are inspired by <a href=https://grpc.github.io/grpc/core/md_doc_statuscodes.html>gRPC status codes</a>. Let me explain each category in one sentence.<p><strong>Not Found Error</strong>: The resource the caller wants does not exist. Example: A deleted Article.<p><strong>Already Exists Error</strong>: The resource the caller wants to create, already exists. Example: An organisation with the same name.<p><strong>Failed Precondition Error</strong>: The operation caller wants to execute does not meet the conditions to execute or is in a bad state. Example: Trying to debit an account with 0 balance.<p><strong>Internal Error</strong>: Any other error which does not fall into these categories is an Internal Error.<p>Just having these types of errors is not enough. You have to let the caller know which kind of error it is. We achieve this using error sentinels and <code class="cw qd qe qf oz b">errors.Is</code>.<p>Imagine you have a REST API where people can fetch and update their wallet balance. Let’s see how we can use error sentinels when fetching wallet from db.<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>import</span> (<br> <span>&#34;fmt&#34;</span><br> <span>&#34;net/http&#34;</span><br> <span>&#34;errors&#34;</span><br>)<br><br><span>// These are error sentinels</span><br><span>var</span> (<br>  ErrWalletDoesNotExist = errors.New(<span>&#34;Wallet does not exist&#34;</span>) <span>//Type of Not Found Error</span><br>  ErrCouldNotGetWallet = errors.New(<span>&#34;Could not get Wallet&#34;</span>) <span>//Type of Internal Error</span><br>)<br><br><span><span>func</span> <span>getWalletFromDB</span><span>(id <span>int</span>)</span></span> (<span>int</span>, <span>error</span>) {<br> <span>// Dummy implementation: simulate retrieving a wallet from a database</span><br> balance, err := db.get(id)<br><br> <span>if</span> err != <span>nil</span> {<br>  <span>if</span> balance == <span>nil</span> {<br>    <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;%w: Wallet(id:%s) does not exist: %w&#34;</span>, ErrWalletDoesNotExist, id, err)<br>  } <span>else</span> {<br>    <span>return</span> <span>0</span>, <span>return</span> fmt.Errorf(<span>&#34;%w: could not get Wallet(id:%s) from db: %w&#34;</span>, ErrCouldNotGetWallet, id, err)<br>  }<br> }<br><br> <span>return</span> *balance, <span>nil</span><br>}</span></pre><p>What makes sentinels REALLY useful is that now the REST handler can do the following<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span><span>func</span> <span>getWalletBalance</span><span>()</span></span> {<br> wallet, err := getWalletFromDB(id)<br><br> <span>if</span> errors.Is(err, ErrWalletDoesNotExist) {<br>  <span>// return 404</span><br> } <span>else</span> <span>if</span> errors.Is(err, ErrCouldNotGetWallet) {<br>  <span>// return 500</span><br> }<br>}</span></pre><p>Let’s see another example where the user wants to update the balance<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span>import</span> (<br> <span>&#34;fmt&#34;</span><br> <span>&#34;net/http&#34;</span><br> <span>&#34;errors&#34;</span><br>)<br><br><span>var</span> (<br>  ErrWalletDoesNotExist = errors.New(<span>&#34;Wallet does not exist&#34;</span>) <span>//Type of Not Found Error</span><br>  ErrCouldNotDebitWallet = errors.New(<span>&#34;Could not debit Wallet&#34;</span>) <span>//Type of Internal Error</span><br>  ErrInsiffucientWalletBalance = errors.New(<span>&#34;Insufficient balance in Wallet&#34;</span>) <span>//Type of Failed Precondition Error</span><br>)<br><br><span><span>func</span> <span>debitWalletInDB</span><span>(id <span>int</span>, amount <span>int</span>)</span></span> <span>error</span> {<br> <span>// Dummy implementation: simulate retrieving a wallet from a database</span><br> balance, err := db.get(id)<br><br> <span>if</span> err != <span>nil</span> {<br>  <span>if</span> balance == <span>nil</span> {<br>    <span>return</span> fmt.Errorf(<span>&#34;%w: Wallet(id:%s) does not exist: %w&#34;</span>, ErrWalletDoesNotExist, id, err)<br>  } <span>else</span> {<br>    <span>return</span> fmt.Errorf(<span>&#34;%w: could not get Wallet(id:%s) from db: %w&#34;</span>, ErrCouldNotDebitWallet, id, err)<br>  }<br> }<br><br> <span>if</span> *balance &lt;= <span>0</span> {<br>   <span>return</span> <span>0</span>, fmt.Errorf(<span>&#34;%w: Wallet(id:%s) balance is 0&#34;</span>, ErrInsiffucientWalletBalance, id)<br> }<br><br> updatedBalance := *balance - amount<br> <br> <span>// Dummy implementation: simulate updating a wallet into a database</span><br> err := db.update(id, updatedBalance)<br><br> <span>if</span> err != <span>nil</span> {<br>   <span>return</span> fmt.Errorf(<span>&#34;%w: could not update Wallet(id:%s) from db: %w&#34;</span>, ErrCouldNotDebitWallet, id, err)<br> }<br><br> <span>return</span> <span>nil</span><br>}</span></pre><h2>Writing better error messages using sentinels</h2><p>You may have already seen I like to format errors in a specific way. I like to structure an error message in one of two ways<ul><li><code class="cw qd qe qf oz b">fmt.Errorf(&#34;%w: description: %w&#34;, Sentinel, err)</code> or<li><code class="cw qd qe qf oz b">fmt.Errorf(&#34;%w: description&#34;, Sentinel)</code></ul><p>This makes sure the error <em>tells a story. </em>The story of <strong>What went wrong, Why and the underlying cause.</strong><p>This is important because as you can see in the above example a same type of error can be caused by two different underlying issues. So description helps us pinpoint exactly what went wrong and why.<h1>Bonus: Where to Log errors</h1><p>You may be surprised that you should <strong>not </strong>log every error you find. Why? you do you end up with logs that look like this<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span>Error: C: negative value not allowed<br>Error: B: C: negative value not allowed<br>Error: A: B: C: negative value not allowed</span></pre><p>Rather you should only log errors <strong>where you “Handle” errors.</strong> By handling errors I mean where the caller upon receiving the error can do something with it and continue executing instead of just returning the error.<p>A prime example would be, again, a REST handler. If a REST handler receives an error it can look at the type of the error and, send appropriate response with status code and stop the propagation of error.<pre class="mt mu mv mw mx oy oz pa bo pb ba bj"><span><span><span>func</span> <span>getWalletBalance</span><span>()</span></span> {<br> wallet, err := getWalletFromDB(id)<br><br> <span>if</span> err != <span>nil</span> {<br>  fmt.Printf(<span>&#34;%w&#34;</span>, err) <span>//Log the error only here</span><br> }<br><br> <span>if</span> errors.Is(err, ErrWalletDoesNotExist) {<br>  <span>// return 404</span><br> } <span>else</span> <span>if</span> errors.Is(err, ErrCouldNotGetWallet) {<br>  <span>// return 500</span><br> }<br>}</span></pre></div></main>
<hr>
<footer>
        <label>原网址: <a href="https://blog.rideapp.in/conquering-errors-in-go-a-guide-to-returns-and-handling-a13885905433" target="_blank" referrerpolicy="no-referrer" rel="noopener noreferrer">访问</a></label><br/>
        <label>创建时间: 2024-05-22 16:24:20</label><br/>
        <br/>
        
      </footer>
</body>
</html>