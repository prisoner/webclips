<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>如何阅读火焰图</title>
    <link rel="stylesheet" href="https://c1312.netlify.app/typo.css">
    <link rel="stylesheet" href="https://c1312.netlify.app/style.css">
</head>
<body>
<header>
  <h1>如何阅读火焰图</h1>
</header>
<main class="typo"><div><p>这篇文章是火焰图阅读的简明教程。<p>火焰图是我们用来分析性能的可视化工具。很多 profile 工具输出的信息都非常多，是一个巨大的文本，在这个文本中，找到性能瓶颈，会比较困难。但是如果画出来一张图，可以一下就看到问题所在。<p>火焰图是 Brendan Gregg 发明的。使用官方的工具 <a href=https://github.com/brendangregg/FlameGraph>FlameGraph</a>，可以将文本渲染成 svg。如下。<figure><a href=https://www.kawabangga.com/wp-content/uploads/2024/03/flamegraph-official.png><img width=1024 height=536 src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/15d15a8b.png></a><figcaption>官方的 FlameGraph 渲染出来的 svg 截图</figcaption></figure><p>现在也会有其他的工具能渲染出来类似的图了，比如 golang 的 pprof 现在内置了一个新版的火焰图预览工具，在线的 <a href=https://www.speedscope.app/>speedscope</a> 也可以渲染。我最喜欢的是 <a href=https://github.com/laixintao/flameshow>Flameshow</a>，一个终端工具，可以直接在终端用字符渲染出来火焰图，设计的非常精妙。（其实就是我自己写的）。由于是我自己写的，那么下文我就以 Flameshow 来做展示的例子了。<figure><a href=https://www.kawabangga.com/wp-content/uploads/2024/03/flameshow-flamegraph.png><img width=1024 height=629 src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/58e812fd.png></a><figcaption>Flameshow</figcaption></figure><h2>阅读方法</h2><p>火焰图作为一个可视化的工具，着重表达的信息是：父子之间的关系，每一个块的占比。<p>火焰图有从下向上的和从上向下的，本质是相同的，只是方块之间的关系方向不同。从上向下：下面的方块是上面的子块；从下向上：上面的方块是下面的子块。<p>主要信息有（以从上到下为例子）：<ul><li>每一个方块，都是一个函数，方块的宽度，就表示函数消耗的时间占比。（如果是内存火焰图，那就表示的这个函数申请的内存占比。）所以我们看火焰图，主要去找最宽的一个方块。<li>上下堆叠在一起的是表示函数调用。Y 轴表示调用的深度。</ul><p>火焰图一般是支持交互式的，svg 和 flameshow 都支持点击其中一个 function，来放大。如下例子：<figure><a href=https://www.kawabangga.com/wp-content/uploads/2024/03/zoom-function.png><img width=1024 height=251 src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/bc0198a9.png></a><figcaption>点击放大其中一个 function</figcaption></figure><p>标记的是，最开始调用的函数是 <code>collector.NodeCollector.Collect.func1</code>，然后这个函数的所有时间都在调用 <code>collector.execute</code>，以此类推。到下下面的 <code>os.(*File).readdir</code>，其中有一大部分是在调用函数 <code>os.Lstat</code>，然后其余的时间花在了 <code>os.direntReclen</code>。<p>很多人对火焰图容易有<strong>一些误解</strong>，这里着重说明一下：<ul><li>Y 轴的深度一般不是问题。我们用火焰图主要是排查性能问题，是要找消耗时间长的地方。调用深度很深，但是没花多久时间，一般不要紧；<li>颜色（几乎）没有意义。<strong>不是说颜色越深时间越久</strong>。颜色只是为了区分出来不同的块而已。一般会将相同名字的函数都使用同一个颜色，这样，即使它们分散在不同的 stack 中，也能清晰看出总时间比较高。从 <a href=https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl#L410>FlameGraph 的源代码</a>也可以看出，颜色是根据 function 名字随机生成的。但是有<a href=https://www.brendangregg.com/blog/2017-07-30/coloring-flamegraphs-code-type.html>一种优化</a>：比如对于 Java 的 JVM 来说，可以用不同的红色表示 Java 代码消耗的时间，可以用黄色表示 Kernel 消耗的时间，用蓝色表示 JIT 时间。但是不同的红色，红色深浅，还是没有什么意义的。<li>方块之间的顺序没有意义。因为火焰图的生成方式（后文介绍），和渲染方式（一般会将同名字的方块 merge 在一起，方便阅读），导致火焰图方块之间的顺序是没有意义的。<strong>不代表函数调用的顺序</strong>。</ul><h2>火焰图的本质是旭日图（Sunburst Graph）</h2><p>你有没有发现，主要表示占比，又能表示占比之间的关系，是不是跟某一种图很像？<figure><a href=https://www.kawabangga.com/wp-content/uploads/2024/03/tokei-pie.png><img width=1024 height=852 src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/aa2587a2.png></a><figcaption>使用 <a href=https://github.com/laixintao/tokei-pie>tokei-pie</a> 渲染出来的旭日图</figcaption></figure><p>是的，其实火焰图的本质就是拉平了的旭日图。上图是我用 <a href=https://github.com/laixintao/tokei-pie>tokei-pie</a> 渲染出来的代码仓库中不同文件夹、文件的行数占比。打开一个新的项目的时候可以轻松找到核心代码。<h2>火焰图的生成和格式</h2><p>火焰图的生成主要依赖 profile 工具，目前很多工具都支持了，比如 <a href=https://github.com/benfred/py-spy>py-spy</a>, golang 的 pprof.<p>生成的原理大致是去扫描程序的内存，主要是内存的 stack 部分，对 stack 做一个快照。如果扫描了 10 次，其中 function1 出现了 3 次，function2 出现了 6 次。那么它们的宽度占比就是 1:2. 很多 profile 工具就是如此工作的，不是 100% 精确的，但足以让我们分析性能问题了。<p>生成的格式一般是 stackcollapse 格式，这是官方的一种定义。比如如下的文本：<div><div><div><span>火焰图文本表示</span><div><div><div></div></div><div><div></div></div><div><div></div></div><div><div></div></div></div></div><div></div><div><table><tbody><tr><td><div><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div><td><div><div><span>a</span><span>;</span><span>b</span><span>;</span><span>c</span><span> </span><span>1</span></div><div><span>a</span><span>;</span><span>b</span><span>;</span><span>c</span><span> </span><span>1</span></div><div><span>a</span><span>;</span><span>b</span><span>;</span><span>d</span><span> </span><span>4</span></div><div><span>a</span><span>;</span><span>b</span><span>;</span><span>c</span><span> </span><span>3</span></div><div><span>a</span><span>;</span><span>b</span><span> </span><span>5</span></div></div></table></div></div></div><div></div><p>每一行就代表一个 stack，数字代表整个 stack 的占比。我们要把所有的 stack 相同层级相同名字的 merge 起来，最后就变成下面这样：<figure><a href=https://www.kawabangga.com/wp-content/uploads/2024/03/flameshow-samples.png><img width=1024 height=118 src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/50ffe3e5.png></a><figcaption>简单的 stackcollapse</figcaption></figure><p>另一种常见的格式是 pprof 的格式。虽然是 golang 最先开始用的，但是<a href=https://www.kawabangga.com/posts/5427>设计的（我个人认为）比较好</a>，也是开源的，<a href=https://github.com/google/pprof/blob/main/proto/profile.proto>protobuf 定义</a>，所以很多工具也支持输出这种格式了。<h2>Continuous Profiling</h2><p>持续 Profiling 也是我比较感兴趣的一个领域，很多 APM 工具都已经支持了。比如 <a href=https://www.datadoghq.com/product/code-profiling/>Datadog</a> 和 <a href=https://grafana.com/products/cloud/profiles-for-continuous-profiling/>Grafana</a>。简单来说，就是不断地对线上部分实例进行 Profile，然后对结果不是简单的展示，而是收集起来。将它们的 stack 都合并起来，做成一个由多个实例的 stack 组成的 Flame Graph，就可以找到集群层面的性能热点了。<p>另外一个用处是，在发布新版本的时候，可以在灰度的时候，检查新版本的 Flame Graph 和之前的，看有没有引入新的性能热点。<h2>相关链接</h2><ol><li><a href=https://www.brendangregg.com/flamegraphs.html>https://www.brendangregg.com/flamegraphs.html</a><li><a href=https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html>https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html</a><li><a href="https://queue.acm.org/detail.cfm?id=2927301">https://queue.acm.org/detail.cfm?id=2927301</a><li><a href=https://youtu.be/6uKZXIwd6M0>https://youtu.be/6uKZXIwd6M0</a><li><a href=https://youtu.be/6uKZXIwd6M0>https://youtu.be/6uKZXIwd6M0</a><li><a href=https://www.webperf.tips/tip/understanding-flamegraphs/>https://www.webperf.tips/tip/understanding-flamegraphs/</a><li><a href=https://github.com/jlfwong/speedscope/wiki>https://github.com/jlfwong/speedscope/wiki</a><li><a href=https://www.speedscope.app/>https://www.speedscope.app/</a></ol><br><hr><div></div></div></main>
<hr>
<footer>
        <label>原网址: <a href="https://www.kawabangga.com/posts/5861" target="_blank" referrerpolicy="no-referrer" rel="noopener noreferrer">访问</a></label><br/>
        <label>创建时间: 2024-03-04 09:45:28</label><br/>
        <br/>
        
      </footer>
<link rel=stylesheet href=https://cp-bkt1.oss-cn-hangzhou.aliyuncs.com/cdn/prism.css>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-twilight.min.css>
<script src=https://cp-bkt1.oss-cn-hangzhou.aliyuncs.com/cdn/prism.js></script>
</body>
</html>