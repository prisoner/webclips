<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>万字长文，带你从零学习Webpack - 掘金</title>
    <link rel="stylesheet" href="https://c1312.netlify.app/typo.css">
    <link rel="stylesheet" href="https://c1312.netlify.app/style.css">
</head>
<body>
<header>
  <h1>万字长文，带你从零学习Webpack - 掘金</h1>
</header>
<main class="typo"><div><div><div><div><main><div><div><article><div><div><p>一直以为，我的<code>Webpack</code>就是复制粘贴的水平，而对<code>Webpack</code>的知识真的很模糊，甚至是纯小白。所以前段时间开始对<code>Webpack</code>进行比较系统的学习。</p>
<p>学习完成后，我抽空整理了笔记，前前后后也花了一周多。最后觉得可以分享出来，让对<code>Webpack</code>还很模糊的朋友，可以学习一下。</p>
<p>当然，读完本文，你会发现<code>Webpack</code>还有更多更深的东西值得我们去学习，因此这只是一个开始，从零开始。</p>
<h1>module、chunk和bundle</h1>
<p>在学习<code>webpack</code>之前，我们需要先来捋一捋三个术语——<code>module</code>、<code>chunk</code>和<code>bundle</code>。</p>
<h2>过一下概念</h2>
<h3>module</h3>
<p>先看看<code>webpack</code>官方对<code>module</code>的解读：</p>
<blockquote>
<p><code>Module</code>是离散功能块，相比于完整程序提供了更小的接触面。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p>
</blockquote>
<p>其实简单来说，<code>module</code>模块就是我们编写的代码文件，比如<code>JavaScript</code>文件、<code>CSS</code>文件、<code>Image</code>文件、<code>Font</code>文件等等，它们都是属于<code>module</code>模块。而<code>module</code>模块的一个特点，就是可以被引入使用。</p>
<h3>chunk</h3>
<p>同样的先看看官方解读：</p>
<blockquote>
<p>此 <code>webpack</code> 特定术语在内部用于管理捆绑过程。输出束（bundle）由块组成，其中有几种类型（例如 <code>entry</code> 和 <code>child</code> ）。通常，块直接与输出束 (<code>bundle</code>）相对应，但是，有些配置不会产生一对一的关系</p>
</blockquote>
<p>其实<code>chunk</code>是<code>webpack</code>打包过程的中间产物，<code>webpack</code>会根据文件的引入关系生成<code>chunk</code>，也就是说一个<code>chunk</code>是由一个<code>module</code>或多个<code>module</code>组成的，这取决于有没有引入其他的<code>module</code>。</p>
<h3>Bundle</h3>
<p>先看看官方解读：</p>
<blockquote>
<p><code>bundle</code> 由许多不同的模块生成，包含已经经过加载和编译过程的源文件的最终版本。</p>
</blockquote>
<p><code>bundle</code>其实是<code>webpack</code>的最终产物，通常来说，一个<code>bundle</code>对应这一个<code>chunk</code>。</p>
<h3>总结</h3>
<p>其实<code>module</code>、<code>chunk</code>和<code>bundle</code>可以说是同一份代码在不同转换场景的不同名称：</p>
<ul>
<li>我们编写的是<code>module</code></li>
<li><code>webpack</code>处理时时<code>chunk</code></li>
<li>最终生成供使用的是<code>bundle</code></li>
</ul>
<h2>实践一下</h2>
<p>我们通过一个小<code>demo</code>来过一下，现在有一个项目，路径如下：</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">src/
├── index.css
├── index.js
├── common.js
└── utils.js
</code></pre>
<p>然后我们有两个入口文件，一个是<code>index.js</code>，一个是<code>utils.js</code>，在<code>index.js</code>中引入了<code>index.css</code>和<code>common.js</code>。然后通过<code>webpack</code>打包出来了<code>index.bundle.css</code>、<code>index.bundle.js</code>和<code>utils.bundle.js</code>。</p>
<p>好，介绍完背景后，我们就可以来分析一下<code>module</code>、<code>chunk</code>和<code>bundle</code>。</p>
<p>首先，我们编写的代码，就是<code>module</code>，也就是说<code>index.css</code>、<code>common.js</code>、<code>index.js</code>和<code>utils.js</code>共四个<code>module</code>文件。</p>
<p>其次，我们有两个入口文件，分别为<code>index.js</code>和<code>utils.js</code>，并且它们最后是独立打包成<code>bundle</code>的，从而在<code>webpack</code>打包过程中就会形成两个<code>chunk</code>文件，而由<code>index.js</code>形成<code>chunk</code>还包含着<code>index.js</code>引入的<code>module</code>——<code>common.js</code>和<code>index.css</code>。</p>
<p>最后，我们打包出来了<code>index.bundle.css</code>、<code>index.bundle.js</code>和<code>uitls.bundle.js</code>，这三个也就是<code>bundle</code>文件。</p>
<p><img src="https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/d24ba122.webp"/></p>
<p>最后，我们可以总结一下三者之间的关系：<strong>一个<code>budnle</code>对应着一个<code>chunk</code>，一个<code>chunk</code>对应着一个或多个<code>module</code></strong>。</p>
<h1>初始化Webpack项目</h1>
<p>接下来，我们通过一步步实践，来慢慢学习<code>webpack</code>，这篇文章使用的是<code>webpack5</code>。</p>
<p>首先，新建一个项目文件夹，然后初始化项目。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">yarn init -y
</code></pre>
<p>然后安装一下<code>webpack</code>。当我们使用<code>webpack</code>时，还需要安装<code>webpack-cli</code>。</p>
<p>因为<code>webpack</code>只是在开发环境才会使用到，所以我们只需要添加到<code>devDependencies</code>即可。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># webpack -&gt; 5.47.0, webpack-cli-&gt; 4.7.2
yarn add webpack webpack-cli -D
</code></pre>
<p>然后再项目中新建<code>src</code>路径，再新建一个<code>index.js</code>：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">console.log(&#34;Hello OUDUIDUI&#34;);
</code></pre>
<p>然后执行<code>npx webpack</code>，则执行<code>webpack</code>打包。这时你的项目就会多一个<code>dist</code>文件夹，并且在<code>dist</code>文件夹中会看到一个<code>main.js</code>，里面的代码跟<code>index.js</code>一样。</p>
<p>当然，我们可以在<code>package.json</code>中编辑<code>script</code>命令：</p>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">&#34;scripts&#34;: {
  &#34;dev&#34;: &#34;webpack&#34;
}
</code></pre>
<p>然后执行<code>yarn dev</code>，也可以成功打包。</p>
<h1>Webpack配置文件</h1>
<p>如果使用过<code>webpack</code>的朋友应该知道，<code>webpack</code>其实有一个配置文件——<code>webpack.config.js</code>。</p>
<p>但为什么前面的初始化测试时，我们没有编辑配置文件却可以成功打包？这是因为<code>webpack</code>会有一个默认配置，当它检测到我们没有配置文件的时候，它默认会使用自己的默认配置。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);

module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;main.js&#39;,
  },
};
</code></pre>
<p>首先，我们简单来过一下这些默认配置叭。</p>
<h2>entry和output</h2>
<p><code>entry</code>选项是用来配置入口文件的，它可以是字符串、数组或者对象类型。<code>webpack</code>默认只支持<code>js</code>和<code>json</code>文件作为入口文件，因此如果引入其他类型文件会保存。</p>
<p><code>output</code>选项是设置输出配置，<strong>该选项必须是对象类型</strong>，不能是其它类型格式。在<code>output</code>对象中，必填的两个选项就是导出路径<code>path</code>和导出<code>bundle</code>文件名称<code>filename</code>。其中<code>path</code>选项必须为绝对路径。</p>
<p><code>entry</code>和<code>output</code>的配置，对于不同的应用场景的配置也会有所不同。</p>
<h3>单入口单输出</h3>
<p>我们最普遍的就是单个入口文件，然后打包成单个<code>bundle</code>文件。这种应用场景下，<code>entry</code>可以使用字符串的形式，则跟默认配置文件类似：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">entry: &#39;./src/index.js&#39;
</code></pre>
<h3>多入口单输出</h3>
<p>当我们的项目需要有多个入口文件，但只需要一个输出<code>bundle</code>的时候，这时候<code>entry</code>可以使用数组的形式：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">entry: [&#39;./src/index_1.js&#39;, &#39;./src/index_2.js&#39;]
</code></pre>
<blockquote>
<p><strong>注意：此时其实只有一个chunk</strong></p>
</blockquote>
<h3>多入口多输出</h3>
<p>当我们的项目同时多个入口文件，并且它们需要单独打包，也就是意味着会有多个<code>bundle</code>文件输出，此时我们的<code>entry</code>需要使用对象形式，并且对象<code>key</code>对应的对应<code>chunk</code>的名称。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">entry: {
  index: &#34;./src/index.js&#34;,  // chunkName为index
  main: &#34;./src/main.js&#34;     // chunkName为main
}
</code></pre>
<p>此时，我们的<code>output.filename</code>也不能写死了，这时候<code>webpack</code>提供了一个占位符<code>[name]</code>给我们使用，它会自动替换为对应的<code>chunkName</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">output: {
   path: path.resolve(__dirname, &#39;dist&#39;),
   filename: &#39;[name].js&#39;  // [name]占位符会自动替换为chunkName
},
</code></pre>
<p>根据上面的配置，最后会打包出<code>index.js</code>和<code>main.js</code>。</p>
<h3>补充</h3>
<p>在单入口单输出的应用场景下，<code>entry</code>也可以使用对象的形式，从而来自定义<code>chunkName</code>，然后<code>output.filename</code>也使用<code>[name]</code>占位符来自动匹配。当然也可以使用数组，但是不太大必要。</p>
<p>当<code>entry</code>使用数组或字符串的时候，<code>chunkName</code>默认为<code>main</code>，因此如果<code>output.filename</code>使用<code>[name]</code>占位符的时候，会自动替换为<code>main</code>。</p>
<h2>mode</h2>
<p>在前面的打包测试的时候，命令行都会报一个警告：</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">WARNING in configuration
The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value.
Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.
</code></pre>
<p>这是因为<code>webpack</code>需要我们配置<code>mode</code>选项。</p>
<p>wepack给我们提供了三个选项，即<code>none</code>、<code>development</code>和<code>production</code>，而默认就是<code>production</code>。</p>
<p>三者的区别呢，在于<code>webpack</code>自带的代码压缩和优化插件使用。</p>
<ul>
<li>
<p><strong><code>none</code></strong>：不使用任何默认优化选项；</p>
</li>
<li>
<p><strong><code>development</code></strong>：指的是开发环境，会默认开启一些有利于开发调试的选项，比如<code>NamedModulesPlugin</code>和<code>NamedChunksPlugin</code>，分别是给<code>module</code>和<code>chunk</code>命名的，而默认是一个数组，对应的<code>chunkName</code>也只是下标，不利于开发调试；</p>
</li>
<li>
<p><strong><code>production</code></strong>：指的是生产环境，则会开启代码压缩和代码性能优化的插件，从而打包出来的文件也相对<code>none</code>和<code>development</code>小很多。</p>
</li>
</ul>
<blockquote>
<p>当我们设置mode之后，我们可以在<code>process.env.NODE_ENV</code>获取到当前的环境</p>
</blockquote>
<p>因此我们可以在配置文件上文件上配置<code>mode</code>：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename: &#39;[name].js&#39;,
    },
    // 配置mode选项
    mode: &#34;development&#34;
};
</code></pre>
<p><code>webpack</code>也给我们提供了另一种方式，就是在命令行中配置，也就是加上<code>--mode</code>：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// package.json
&#34;scripts&#34;: {
  &#34;dev&#34;: &#34;webpack --mode development&#34;,
  &#34;build&#34;: &#34;webpack --mode production&#34;
}
</code></pre>
<h2>devtool</h2>
<p>聊完<code>mode</code>后，说到开发调试，不难想起的就是<code>sourceMap</code>。而我们可以在配置文件中，使用<code>devtool</code>开启它。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename: &#39;[name].js&#39;,
    },
  	// 开启source-map
    devtool: &#34;source-map&#34;
};
</code></pre>
<p>打包后，你的<code>dist</code>中就会多了一个<code>main.js.map</code>文件。</p>
<p>当然，官方不止提供这么一个选项，具体的可以去<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fdevtool%2F%23devtool">官网</a>看看，这里就说其他几个比较常用的选项。</p>
<ul>
<li>
<p><strong><code>none</code></strong>：不会生成<code>sourceMap</code>；</p>
</li>
<li>
<p><strong><code>eval</code></strong>：每个模块都会使用<code>eval()</code>执行，不建议生成环境中使用；</p>
</li>
<li>
<p><strong><code>cheap-source-map</code></strong>：生成<code>sourceMap</code>，但是没有列映射，则只会提醒是在代码的第几行，不会提示到第几列；</p>
</li>
<li>
<p><strong><code>inline-source-map</code></strong>：会生成<code>sourceMap</code>，但不会生成<code>map</code>文件，而是将<code>sourceMap</code>放在打包文件中。</p>
</li>
</ul>
<h2>module</h2>
<p>前面我们有提到过，就是<code>webpack</code>的入口文件只能接收<code>JavaScript</code>文件和<code>JSON</code>文件。</p>
<p>但我们通常项目还会有其他类型的文件，比如<code>html</code>、<code>css</code>、图片、字体等等，这时候我们就需要用到第三方<code>loader</code>来帮助<code>webpack</code>来解析这些文件。理论上只要有相应的<code>loader</code>，就可以处理任何类型的文件。</p>
<blockquote>
<p>在<code>webpack</code><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Floaders%2F">官网</a>其实提供了很多<code>loader</code>，已经能满足我们日常使用，当然我们也可以去<code>github</code>找找别人写的<code>loader</code>或者自己手写<code>loader</code>来使用。</p>
</blockquote>
<p>而对于<code>loader</code>的配置，是写着<code>module</code>选项里面的。<code>module</code>选项是一个对象，它里面有一个<code>rules</code>属性，是一个数组，在里面我们可以配置多个匹配规则。</p>
<p>而匹配规则是一个对象，会有<code>test</code>属性和<code>use</code>属性，<code>test</code>属性一般是正则表达式，用来识别文件类型，而<code>use</code>属性是一个数组，里面用来存放对该文件类型使用的<code>loader</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module: {
    rules: [
        {
          test: /\.css$/,  // 识别css文件
          use: [&#39;style-loader&#39;, &#39;css-loader&#39;]  // 对css文件使用的三个loader
        }
    ]
}
</code></pre>
<p>对于<code>use</code>数组的顺序是有要求的，<code>webpack</code>会根据<strong>自后向前</strong>的规则去执行<code>loader</code>。也就是说，上面的例子<code>webpack</code>会先执行<code>css-loader</code>，再执行<code>style-loader</code>。</p>
<p>其次，当我们需要对对应<code>loader</code>提供配置的时候，我们可以选用对象写法：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module: {
    rules: [
        {
          test: /\.css$/,  
          use: [
            &#39;style-loader&#39;, 
            {
              	// loader名称
              	loader: &#39;css-loader&#39;,
              	// loader选项
              	options: {
                  	... 
                }
            }
          ] 
        }
    ]
}
</code></pre>
<p>在后面我们根据实际应用场景再讲讲<code>module</code>的使用。</p>
<h2>plugins</h2>
<p><code>webpack</code>还提供了一个<code>plugins</code>选项，让我们可以使用一些第三方插件，因此我们可以使用第三方插件来实现打包优化、资源管理、注入环境变量等任务。</p>
<blockquote>
<p>同样的，<code>webpack</code><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2F">官方</a>也提供了很多<code>plugin</code>。</p>
</blockquote>
<p><code>plugins</code>选项是一个数组，里面可以放入多个<code>plugin</code>插件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">plugins: [
  new htmlWebpackPlugin(),
  new CleanWebpackPlugin(),
  new miniCssExtractPlugin(),
  new TxtWebpackPlugin()
]
</code></pre>
<p>而对于<code>plugins</code>数组对排序位置是没有要求，因为在<code>plugin</code>的实现中，<code>webpack</code>会通过打包过程的生命周期钩子，因此在插件逻辑中就已经设置好需要在哪个生命周期执行哪些任务。</p>
<h1>实现一下常见的应用场景</h1>
<h2>HTML模板</h2>
<p>当我们是<code>Web</code>项目的时候，我们必然会存在<code>html</code>文件去实现页面。</p>
<p>而对于其他类型的文件，比如<code>css</code>、图片、文件等等，我们是可以通过引入入口<code>js</code>文件，然后通过<code>loader</code>进行解析打包。而对于<code>html</code>文件，我们不可能将其引入到入口文件然后解析打包，反而我们还需要将打包出来的<code>bundle</code>文件引入<code>html</code>文件去使用，</p>
<p>因此，其实我们需要实现的操作只有两个，一个是复制一份<code>html</code>文件到打包路径下，另一个就是将打包出来的<code>bundle</code>文件自动引入到<code>html</code>文件中去。</p>
<p>这时候我们需要使用一个插件来实现这些功能——<code>html-webpack-plugin</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 5.3.2
yarn add html-webpack-plugin -D
</code></pre>
<p>安装插件后，我们先在<code>src</code>文件下新建一下<code>index.html</code>。</p>
<pre><code class="hljs language-html copyable code-block-extension-codeShowNum">


    
    Webpack Demo


    Hello World


</code></pre>
<p>这里面我们暂时不需要引入任何模块。</p>
<p>接下来配置一下<code>webpack</code>。一般<code>plugin</code>插件都是一个类，而我们需要在<code>plugins</code>选项中需要创建一个插件实例。</p>
<p>对于<code>htmlWebpackPlugin</code>插件，我们需要传入一些配置：<code>html</code>模板地址<code>template</code>和打包出来的文件名<code>filename</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);
// 引入htmlWebpackPlugin
const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename: &#39;[name].js&#39;,
    },
    plugins: [
      	// 使用htmlWebpackPlugin插件
        new htmlWebpackPlugin({
         	 // 指定html模板
            template: &#39;./src/index.html&#39;,  
          	// 自定义打包的文件名
            filename: &#39;index.html&#39;
        })
    ]
};
</code></pre>
<p>接下来执行一下打包，就会发现<code>dist</code>文件下会生成一个<code>index.html</code>。打开会发现，<code>webpack</code>会自动将<code>bundle</code>文件引入：</p>
<pre><code class="hljs language-html copyable code-block-extension-codeShowNum">


    
    Webpack Demo


    Hello World


</code></pre>
<p>如果我们有多个<code>chunk</code>的时候，我们可以指定该<code>html</code>要引入哪些<code>chunk</code>。在<code>htmlWebpackPlugin</code>配置中有一个<code>chunks</code>选项，是一个数组，你只需要加入你想引入的<code>chunkName</code>即可。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);
// 引入htmlWebpackPlugin
const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = {
    entry: {
      	index: &#39;./src/index.js&#39;,
      	main: &#39;./src/main.js&#39;
    },
    output: {
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename: &#39;[name].js&#39;,
    },
    plugins: [
        new htmlWebpackPlugin({
            template: &#39;./src/index.html&#39;,  
            filename: &#39;index.html&#39;,
          	chunks: [&#34;index&#34;]  // 只引入index chunk
        })
    ]
};
</code></pre>
<p>打包完成后，<code>dist</code>文件下会出现<code>index.html</code>、<code>index.js</code>和<code>main.js</code>，但是<code>index.html</code>只会引入<code>index.js</code>。</p>
<pre><code class="hljs language-html copyable code-block-extension-codeShowNum">


    
    
    
    Document


    HelloWorld！


</code></pre>
<p>如果我们需要实现多页面的话，只需要再<code>new</code>一个<code>htmlWebpackPlugin</code>实例即可，这里就不再多说。</p>
<h2>清理打包路径</h2>
<p>在每次打包前，我们其实都需要去清空一下打包路径的文件。</p>
<p>如果文件重名的话，<code>webpack</code>还会自动覆盖，但是实际中我们都会在打包文件名称中加入哈希值，因此清空的操作不得不实现。</p>
<p>这时候我们需要使用一个插件——<code>clean-webpack-plugin</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">yarn add clean-webpack-plugin -D
</code></pre>
<p>然后只需引入到配置文件且在<code>plugins</code>配置就可以使用了。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);
// 引入CleanWebpackPlugin
const {CleanWebpackPlugin} = require(&#39;clean-webpack-plugin&#39;);

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        path: path.resolve(__dirname, &#39;dist/&#39;),
        filename: &#39;[name].js&#39;,
        publicPath: &#39;&#39;
    },
    plugins: [
      	// 使用CleanWebpackPlugin
        new CleanWebpackPlugin(),
    ]
};
</code></pre>
<p>有些情况下，我们不需要完全清空打包路径，这时候我们可以使用到一个选项，叫<code>cleanOnceBeforeBuildPatterns</code>，它是一个数组，默认是<code>[**/*]</code>，也就是清理<code>output.path</code>路径下所有东西。而你可以在里面输入只想删除的文件，同时我们可以输入不想删除的文件，只需要在前面加上一个<code>!</code>。</p>
<blockquote>
<p>需要注意的是，<code>cleanOnceBeforeBuildPatterns</code>这个选项是可以删除打包路径下之外的文件，只需要你配上绝对路径的话。因此<code>CleanWebpackPlugin</code>还提供了一个选项供测试——<code>dry</code>，默认是为<code>false</code>，当你设置为<code>true</code>后，它就不会真正的执行删除，而是只会在命令行打印出被删除的文件，这样子更好的避免测试过程中误删。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);
const {CleanWebpackPlugin} = require(&#39;clean-webpack-plugin&#39;);

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        path: path.resolve(__dirname, &#39;dist/&#39;),
        filename: &#39;[name].js&#39;,
        publicPath: &#39;&#39;
    },
    plugins: [
        new CleanWebpackPlugin({
          	// dry: true   // 打开可测试，不会真正执行删除动作
            cleanOnceBeforeBuildPatterns: [
                &#39;**/*&#39;,  // 删除dist路径下所有文件
                `!package.json`,  // 不删除dist/package.json文件
            ],
        }),
    ]
};
</code></pre>
<h2>Webpack本地服务</h2>
<p>当我们使用<code>webpack</code>的时候，不仅仅只是用于打包文件，大部分我们还会依赖<code>webpack</code>来搭建本地服务，同时利用其热更新的功能，让我们更好的开发和调试代码。</p>
<p>接下来我们来安装一下<code>webpack-dev-server</code>：</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 版本为3.11.2
yarn add webpack-dev-server -D
</code></pre>
<p>然后执行下列代码开启服务：</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">npx webpack serve
</code></pre>
<p>或者在package.json配置一下：</p>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">&#34;scripts&#34;: {
  &#34;serve&#34;: &#34;webpack serve --mode development&#34;
}
</code></pre>
<p>然后通过<code>yarn serve</code>运行。</p>
<p>这时，webpack会默认开启<code>http://localhost:8080/</code>服务（具体看你们运行返回的代码），而该服务指向的是<code>dist/index.html</code>。</p>
<p>但你会发现，你的<code>dist</code>中其实是没有任何文件的，这是因为<code>webpack</code>将实时编译后的文件都保存到了内存当中。</p>
<h3>webpack-dev-server的好处</h3>
<p>其实<code>webpack</code>自带提供了<code>--watch</code>命令，可以实现动态监听文件的改变并实时打包，输出新的打包文件。</p>
<p>但这种方案存在着几个缺点，一就是每次你一修改代码，webpack就会全部文件进行重新打包，这时候每次更新打包的速度就会慢了很多；其次，这样的监听方式做不到热更新，即每次你修改代码后，webpack重新编译打包后，你就得手动刷新浏览器，才能看到最新的页面结果。</p>
<p>而<code>webpack-dev-server</code>，却有效了弥补这两个问题。它的实现，是使用了<code>express</code>启动了一个<code>http</code>服务器，来伺候资源文件。然后这个<code>http</code>服务器和客户端使用了<code>websocket</code>通讯协议，当原始文件作出改动后，<code>webpack-dev-server</code>就会实时编译，然后将最后编译文件实时渲染到页面上。</p>
<h3>webpack-dev-server配置</h3>
<p>在<code>webpack.config.js</code>中，有一个<code>devServer</code>选项是用来配置<code>webpack-dev-server</code>，这里简单讲几个比较常用的配置。</p>
<h4>port</h4>
<p>我们可以通过port来设置服务器端口号。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  
    ...
  
    // 配置webpack-dev-server
    devServer: {
        port: 8888,  // 自定义端口号
    },
};
</code></pre>
<h4>open</h4>
<p>在<code>devServer</code>中有一个<code>open</code>选项，默认是为<code>false</code>，当你设置为<code>true</code>的时候，你每次运行<code>webpack-dev-server</code>就会自动帮你打开浏览器。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  
    ...
  
    // 配置webpack-dev-server
    devServer: {
        open: true,   // 自动打开浏览器窗口
    },
};
</code></pre>
<h4>proxy</h4>
<p>这个选项是用来设置本地开发的跨域代理的，关于跨域的知识就不多在这说了，这里就说说如何去配置。</p>
<p><code>proxy</code>的值必须是一个对象，在里面我们可以配置一个或多个跨域代理。最简单的配置写法就是地址配上<code>api</code>地址。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  
    ...
  
    devServer: {
      	// 跨域代理
        proxy: {
          &#39;/api&#39;: &#39;http://localhost:3000&#39;
        },
    },
};
</code></pre>
<p>这时候，当你请求<code>/api/users</code>的时候，就会代理到<code>http://localhost:3000/api/users</code>。</p>
<p>如果你不需要传递<code>/api</code>的话，你就需要使用对象的写法，从而增加一些配置选项：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    //...
    devServer: {
      	// 跨域代理
        proxy: {
            &#39;/api&#39;: {
              target: &#39;http://localhost:3000&#39;,  // 代理地址
              pathRewrite: { &#39;^/api&#39;: &#39;&#39; },   // 重写路径
            },
        },
    },
};
</code></pre>
<p>这时候，当你请求<code>/api/users</code>的时候，就会代理到<code>http://localhost:3000/users</code>。</p>
<p>在proxy中的选项，还有两个比较常用的，一个就是<code>changeOrigin</code>，默认情况下，代理时会保留主机头的来源，当我们将其设置为<code>true</code>可以覆盖这种行为；还有一个是<code>secure</code>选项，当你的接口使用了<code>https</code>的时候，需要将其设置为<code>false</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    //...
    devServer: {
      	// 跨域代理
        proxy: {
            &#39;/api&#39;: {
              target: &#39;http://localhost:3000&#39;,  // 代理地址
              pathRewrite: { &#39;^/api&#39;: &#39;&#39; },   // 重写路径
              secure: false,  // 使用https
              changeOrigin: true   // 覆盖主机源
            },
        },
    },
};
</code></pre>
<h2>CSS处理</h2>
<p>接下来讲讲关于<code>webpack</code>对<code>css</code>的解析处理叭。</p>
<h3>解析CSS文件</h3>
<p>在前面的例子也能看到，我们解析<code>css</code>需要用到的<code>loader</code>有<code>css-loader</code>和<code>style-loader</code>。<code>css-loader</code>主要用来解析<code>css</code>文件，而<code>style-loader</code>是将<code>css</code>渲染到<code>DOM</code>节点上。</p>
<p>首先我们来安装一下：</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"> # css-loader -&gt; 6.2.0;  style-loader -&gt; 3.2.1
 yarn add css-loader style-loader -D
</code></pre>
<p>然后我们新建一个<code>css</code>文件。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">/* style.css */
body {
  background: #222;
  color: #fff;
}
</code></pre>
<p>然后在<code>index.js</code>引入一下：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">import &#34;./style.css&#34;;
</code></pre>
<p>紧接着我们配置一下<code>webpack</code>：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
   ...
  
  module: {
    rules: [
      {
        test: /\.css$/,  // 识别css文件
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]  // 先使用css-loader,再使用style-loader
      }
    ]
  },
  
   ...
};
</code></pre>
<p>这时候我们打包一下，会发现<code>dist</code>路径下只有<code>main.js</code>和<code>index.html</code>。但打开一下<code>index.html</code>会发现<code>css</code>是生效的。</p>
<p><img src="https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/510b033e.webp"/></p>
<p>这是因为<code>style-loader</code>是将<code>css</code>代码插入到了<code>main.js</code>当中去了。</p>
<h3>打包css文件</h3>
<p>如果我们不想将<code>css</code>代码放进<code>js</code>中，而是直接导出一份<code>css</code>文件的话，就得使用另一个插件——<code>mini-css-extract-plugin</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 2.1.0
yarn add mini-css-extract-plugin -D
</code></pre>
<p>然后将其引入到配置文件，并且在<code>plugins</code>引入。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const miniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

module.exports = {
    ...
  
    plugins: [
      	// 使用miniCssExtractPlugin插件
        new miniCssExtractPlugin({
          	filename: &#34;[name].css&#34;  // 设置导出css名称，[name]占位符对应chunkName
        })
    ]
};
</code></pre>
<p>紧接着，我们还需要更改一下<code>loader</code>，我们不再使用<code>style-loader</code>，而是使用<code>miniCssExtractPlugin</code>提供的<code>loader</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const miniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

module.exports = {
    ...
  
    module: {
        rules: [
            {
                test: /\.css$/,
              	// 使用miniCssExtractPlugin.loader替换style-loader
                use: [miniCssExtractPlugin.loader,&#39;css-loader&#39;]
            }
        ]
    },
    plugins: [
        new miniCssExtractPlugin({
          	filename: &#34;[name].css&#34; 
        })
    ]
};
</code></pre>
<p>接下来打包一下，<code>dist</code>路径下就会多出一个<code>main.css</code>文件，并且在<code>index.html</code>中也会自动引入。</p>
<pre><code class="hljs language-html copyable code-block-extension-codeShowNum">


    
    
    
    Document


    HelloWorld！


</code></pre>
<h3>css添加浏览器前缀</h3>
<p>当我们使用一下<code>css</code>新特性的时候，可能需要考虑到浏览器兼容的问题，这时候可能需要对一些<code>css</code>属性添加浏览器前缀。而这类工作，其实可以交给<code>webpack</code>去实现。准确来说，是交给<code>postcss</code>去实现。</p>
<p><code>postcss</code>对于<code>css</code>犹如<code>babel</code>对于<code>JavaScript</code>，它专注于对转换<code>css</code>，比如添加前缀兼容、压缩<code>css</code>代码等等。</p>
<p>首先我们需要先安装一下<code>postcss</code>和<code>post-css-loader</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># postcss -&gt; 8.3.6，postcss-loader -&gt; 6.1.1
yarn add postcss postcss-loader -D
</code></pre>
<p>接下来，我们在<code>webpack</code>配置文件先引入<code>postcss-loader</code>，它的顺序是在<code>css-loader</code>之前执行的。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">rules: [
  {
    test: /\.css$/,
    // 引入postcss-loader
    use: [miniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;]
  }
]
</code></pre>
<p>接下来配置<code>postcss</code>的工作，就不在<code>webpack</code>的配置文件里面了。<code>postcss</code>自身也是有配置文件的，我们需要在项目根路径下新建一个<code>postcss,config.js</code>。然后里面也有一个配置项，为<code>plugins</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    plugins: []
}
</code></pre>
<p>这也意味着，<code>postcss</code>自身也支持很多第三方插件使用。</p>
<p>现在我们想实现的添加前缀的功能，需要安装的插件叫<code>autoprefixer</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 1.22.10
yarn add autoprefixer -D
</code></pre>
<p>然后我们只需要引入到<code>postcss</code>的配置文件中，并且它里面会有一个配置选项，叫<code>overrideBrowserslist</code>，是用来填写适用浏览器的版本。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    plugins: [
        // 将css编译为适应于多版本浏览器
        require(&#39;autoprefixer&#39;)({
            // 覆盖浏览器版本
          	// last 2 versions: 兼容各个浏览器最新的两个版本
          	// &gt; 1%: 浏览器全球使用占有率大于1%
            overrideBrowserslist: [&#39;last 2 versions&#39;, &#39;&gt; 1%&#39;]
        })
    ]
}
</code></pre>
<p>关于<code>overrideBrowserslist</code>的选项填写，我们可以去参考一下<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist">browserslist</a>，这里就不多讲。</p>
<p>当然，我们其实可以在<code>package.json</code>中填写兼容浏览器信息，或者使用<code>browserslist</code>配置文件<code>.browserslistrc</code>来填写，这样子如果我们以后使用其他插件也需要考虑到兼容浏览器的时候，就可以统一用到，比如说<code>babel</code>。</p>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">// package.json 文件
{
  ...
  &#34;browserslist&#34;: [&#39;last 2 versions&#39;, &#39;&gt; 1%&#39;]
}

</code></pre>
<pre><code class="hljs language-markdown copyable code-block-extension-codeShowNum"># .browserslsetrc 文件
last 2 versions
&gt; 1%
</code></pre>
<p>但如果你多个地方都配置的话，<code>overrideBrowserslist</code>的优先级是最高的。</p>
<p>接下来，我们修改一下<code>style.css</code>，使用一下比较新的特性。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">body {
    display: flex;
}
</code></pre>
<p>然后打包一下，看看打包出来后的<code>main.css</code>。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">body {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
}
</code></pre>
<h3>压缩css代码</h3>
<p>当我们需要压缩<code>css</code>代码的时候，可以使用<code>postcss</code>另一个插件——<code>cssnano</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 5.0.7
yarn add cssnano -D
</code></pre>
<p>然后还是在<code>postcss</code>配置文件中引入：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    plugins: [
        ... ,
        require(&#39;cssnano&#39;)
    ]
}
</code></pre>
<p>打包一下，看看<code>main.css</code>。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">body{display:-webkit-box;display:-ms-flexbox;display:flex}
</code></pre>
<h3>解析CSS预处理器</h3>
<p>在现在我们实际开发中，我们会更多使用<code>Sass</code>、<code>Less</code>或者<code>stylus</code>这类<code>css</code>预处理器。而其实<code>html</code>是无法直接解析这类文件的，因此我们需要使用对应的<code>loader</code>将其转换成<code>css</code>。</p>
<p>接下来，我就以<code>sass</code>为例，来讲一下如何使用<code>webpack</code>解析<code>sass</code>。</p>
<p>首先我们需要安装一下<code>sass</code>和<code>sass-loader</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># sass -&gt; 1.36.0, sass-loader -&gt; 12.1.0
yarn add sass sass-loader -D
</code></pre>
<p>然后我们在<code>module</code>加上<code>sass</code>的匹配规则，<code>sass-loader</code>的执行顺序应该是排第一，我们需要先将其转换成<code>css</code>，然后才能执行后续的操作。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">rules: [
  ...
  
  {
    test: /\.(scss|sass)$/,
    use: [miniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
  }
]
</code></pre>
<p>然后我们在项目中新建一个<code>style.scss</code>。</p>
<pre><code class="hljs language-scss copyable code-block-extension-codeShowNum">$color-white: #fff;
$color-black: #222;

body {
    background: $color-black;

    div {
        color: $color-white;
    }
}
</code></pre>
<p>然后在<code>index.js</code>引入。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">import &#34;./style.css&#34;;
import &#34;./style.scss&#34;;
</code></pre>
<p>然后执行打包，再看看打包出来的<code>main.css</code>，<code>scss</code>文件内容被解析到里面，同时如果我们引入多个<code>css</code>或<code>css</code>预处理器文件的话，<code>miniCssExtractPlugin</code>也会将其打包成一个<code>bundle</code>文件里面。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">body{display:-webkit-box;display:-ms-flexbox;display:flex}
body{background:#222}body div{color:#fff}
</code></pre>
<h2>其他静态资源处理</h2>
<p>当我们使用了图片、视频或字体等等其他静态资源的话，我们需要用到<code>url-loader</code>和<code>file-loader</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># url-loader -&gt; 4.1.1; file-loader -&gt; 6.2.0
yarn add url-loader file-loader -D
</code></pre>
<p>首先我们在项目中引入一张图片，然后在引入到<code>index.js</code>中。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">import pic from &#34;./image.png&#34;;

const img = new Image();
img.src= pic;
document.querySelector(&#39;body&#39;).append(img);
</code></pre>
<p>然后我先使用<code>url-loader</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...
  
  module: {
    rules: [
      {
        test: /\.(png|je?pg|gif|webp)$/,
        use: [&#39;url-loader&#39;]
      }
    ]
  }
};
</code></pre>
<p>然后执行一下打包。</p>
<p>你会发现，<code>dist</code>路径下没有图片文件，但是你打开页面是可以看到图片的，且通过调试工具，我们可以看到其实<code>url-loader</code>默认会将静态资源转成<code>base64</code>。</p>
<p><img src="https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/0cffdb40.webp"/></p>
<p>当然，<code>url-loader</code>选项有提供一个属性，叫<code>limit</code>，就是我们可以设置一个文件大小阈值，当文件大小超过这个值的时候，<code>url-loader</code>就不会转成<code>base64</code>，而是直接打包成文件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...
  
  module: {
    rules: [
      {
        test: /\.(png|je?pg|gif|webp)$/,
        use: [{
          loader: &#39;url-loader&#39;,
          options: {
            name: &#39;[name].[ext]&#39;,   // 使用占位符设置导出名称
            limit: 1024 * 10  // 设置转成base64阈值，大于10k不转成base64
          }
        }]
      }
    ]
  }
};
</code></pre>
<p>这时候我们再打包一下，<code>dist</code>文件夹下就会出现了图片文件。</p>
<p>而<code>file-loader</code>其实跟<code>url-loader</code>差不多，但它默认就是导出文件，而不会导出<code>base64</code>的。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...
  
  module: {
    rules: [
      {
        test: /\.(png|je?pg|gif|webp)$/,
        use: [&#39;file-loader&#39;]
      }
    ]
  }
};
</code></pre>
<p>打包一下，会发现<code>dist</code>文件夹下依旧会打包成一个图片文件，但是它的名称会被改成哈希值，我们可以通过<code>options</code>选项来设置导出的名称。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...
  
  module: {
    rules: [
      {
        test: /\.(png|je?pg|gif|webp)$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            name: &#39;[name].[ext]&#39;,   // 使用占位符设置导出名称
          }
        }]
      }
    ]
  }
};
</code></pre>
<p>而对于视频文件、字体文件，也是用相同的方法，只不过是修改<code>test</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...
  module: {
    rules: [
      // 图片
      {
        test: /\.(png|je?pg|gif|webp)$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            esModule: false,
            name: &#39;[name].[ext]&#39;,
            limit: 1024 * 10
          }
        }
      },
      // 字体
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            name: &#39;[name].[ext]&#39;,
            limit: 1024 * 10
          }
        }
      },
      // 媒体文件
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            name: &#39;[name].[ext]&#39;,
            limit: 1024 * 10
          }
        }
      }
    ]
  }
};
</code></pre>
<p>但现在有个问题，就是如果直接在<code>index.html</code>引入图片的话，可以顺利打包吗？</p>
<p>答案是不会的，我们可以测试一下。首先将图片引入<code>index.html</code>。</p>
<pre><code class="hljs language-html copyable code-block-extension-codeShowNum">


    
    
    
    Document


    


</code></pre>
<p>然后执行打包后，打包出来的<code>index.html</code>照样是<code>&lt;img src=&#34;./image.png&#34;&gt;</code>，但是我们并没有解析和打包出来<code>image.png</code>出来。</p>
<p>这时候我们需要借助另一个插件——<code>html-withimg-loader</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 0.1.16
yarn add html-withimg-loader -D
</code></pre>
<p>然后我们再添加一条<code>rules</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">{ test: /\.html$/,loader: &#39;html-withimg-loader&#39; }
</code></pre>
<p>这时候打包成功后，<code>dist</code>文件成功将图片打包出来了，但是打开页面的时候，图片还是展示不出来。然后通过调试工具看的话，会发现</p>
<pre><code class="hljs language-html copyable code-block-extension-codeShowNum">
</code></pre>
<p>这是因为<code>html-loader</code>使用的是<code>commonjs</code>进行解析的，而<code>url-loader</code>默认是使用<code>esmodule</code>解析的。因此我们需要设置一下<code>url-loader</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">{
  test: /\.(png|je?pg|gif|webp)$/,
    use: {
      loader: &#39;url-loader&#39;,
        options: {
          esModule: false,  // 不适用esmodule解析
          name: &#39;[name].[ext]&#39;,
          limit: 1024 * 10
        }
    }
}
</code></pre>
<p>这时候重新打包一下，页面就能成功展示图片了。</p>
<h3>Webpack5 资源模块</h3>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Fasset-modules%2F">webpack.docschina.org/guides/asse…</a></p>
</blockquote>
<p>在<code>webpack5</code>中，新添了一个资源模块，它允许使用资源文件（字体，图标等）而无需配置额外 <code>loader</code>，具体的内容大家可以看看文档，这里简单讲一下如何操作。</p>
<p>前面的例子，我们对静态资源都使用了<code>url-loader</code>或者<code>file-loader</code>，而在<code>webpack5</code>，我们甚至可以需要手动去安装和使用这两个<code>loader</code>，而直接设置一个<code>type</code>属性。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">{
  test: /\.(png|jpe?g|gif|svg|eot|ttf|woff|woff2)$/i,
  type: &#34;asset/resource&#34;,
}
</code></pre>
<p>然后打包测试后，静态文件都会直接打包成文件并自动引入，效果跟<code>file-loader</code>一致。</p>
<p><code>type</code>值提供了四个选项：</p>
<ul>
<li><strong><code>asset/resource</code>：</strong> 发送一个单独的文件并导出 URL。之前通过使用 <code>file-loader</code> 实现。</li>
<li><strong><code>asset/inline</code> ：</strong> 导出一个资源的 data URI。之前通过使用 <code>url-loader</code> 实现。</li>
<li>**<code>asset/source </code> ：**导出资源的源代码。之前通过使用 <code>raw-loader</code> 实现。</li>
<li><strong><code>asset</code>：</strong>  在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 <code>url-loader</code>，并且配置资源体积限制实现。</li>
</ul>
<p>同时，我们可以在<code>output</code>设置输出<code>bundle</code>静态文件的名称：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">output: {
  path: path.resolve(__dirname, &#39;dist/&#39;),
  filename: &#39;[name].js&#39;,
  // 设置静态bundle文件的名称
  assetModuleFilename: &#39;[name][ext]&#39;
}
</code></pre>
<h2>JavaScript转义</h2>
<p>不仅仅<code>css</code>需要转义，<code>JavaScript</code>也要为了兼容多浏览器进行转义，因此我们需要用到<code>babel</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 8.2.2
yarn add babel-loader -D
</code></pre>
<p>同时，我们需要使用<code>babel</code>中用于<code>JavaScript</code>兼容的插件：</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># @babel/preset-env -&gt; 7.14.9; @babel/core -&gt; 7.14.8; @core-js -&gt; 3.16.0
yarn add @babel/preset-env @babel/core core-js -D
</code></pre>
<p>接下来，我们需要配置一下<code>webpack</code>的配置文件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">{
  test: /\.js$/,
  use: [&#39;babel-loader&#39;] 
}
</code></pre>
<p>然后我们需要配置一下<code>babel</code>。当然我们可以直接在<code>webpack.config.js</code>里面配置，但是<code>babel</code>同样也提供了配置文件<code>.babelrc</code>，因此我们就直接在这边进行配置。</p>
<p>在根路径新建一个<code>.babelrc</code>。</p>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">{
  &#34;presets&#34;: [
    [
      &#34;@babel/preset-env&#34;,
      {
      	// 浏览器版本
        &#34;targets&#34;: {
          &#34;edge&#34;: &#34;17&#34;,
          &#34;chrome&#34;: &#34;67&#34;
        },
         // 配置corejs版本，但需要额外安装corejs
        &#34;corejs&#34;: 3,
        // 加载情况
        // entry: 需要在入口文件进入@babel/polyfill，然后babel根据使用情况按需载入
        // usage: 无需引入，自动按需加载
        // false: 入口文件引入，全部载入
        &#34;useBuiltIns&#34;: &#34;usage&#34;
      }
    ]
  ]
}
</code></pre>
<p>接下来，我们来测试一下，先修改一下<code>index.js</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">new Promise(resolve =&gt; {
    resolve(&#39;HelloWorld&#39;)
}).then(res =&gt; {
    console.log(res);
})
</code></pre>
<p>然后执行<code>yarn build</code>进行打包。</p>
<p>在使用<code>babel</code>之前，打包出来的<code>main.js</code>如下。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">!function(){&#34;use strict&#34;;new Promise((o=&gt;{o(&#34;HelloWorld&#34;)})).then((o=&gt;{console.log(o)}))}();
</code></pre>
<p>上面打包代码是直接使用了<code>Promise</code>，而没有考虑到低版本浏览器的兼容。然后我们打开<code>babel</code>后，执行一下打包命令，会发现代码多出了很多。</p>
<p>而在打包代码中，可以看到<code>webpack</code>使用了<code>polyfill</code>实现<code>promise</code>类，然后再去调用，从而兼容了低版本浏览器没有<code>promise</code>属性问题。</p>
<h2>文件归类</h2>
<p>在目前我们的测试代码中，我们的<code>src</code>文件夹如下：</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">├── src
│   ├── Alata-Regular.ttf
│   ├── image.png
│   ├── index.html
│   ├── index.js
│   ├── style.css
│   └── style.scss
</code></pre>
<p>而正常项目的话，我们会使用文件夹将其分好类，这并不难，我们先简单归类一下。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">├── src
│   ├── index.html
│   ├── js
│   │   └── index.js
│   ├── static
│   │   └── image.png
│   │   └── Alata-Regular.ttf
│   └── style
│       ├── style.css
│       └── style.scss

</code></pre>
<p>接下来，我们需要打包出来的文件也是归类好的，这里就不太复杂，直接用一个<code>assets</code>文件夹将所有静态文件放进去，然后<code>index.html</code>放外面。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">├── dist
│   ├── assets
│   │   ├── Alata-Regular.ttf
│   │   ├── image.png
│   │   ├── main.css
│   │   └── main.js
│   └── index.html
</code></pre>
<p>这里先补充一下<code>style.css</code>引入字体的代码：</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">@font-face {
    font-family: &#34;test-font&#34;;
    src: url(&#34;../static/Alata-Regular.ttf&#34;) format(&#39;truetype&#39;)
}

body {
    display: flex;
    font-family: &#34;test-font&#34;;
}
</code></pre>
<p>首先，我们先将打包出来的<code>JavaScript</code>文件放入<code>assets</code>文件夹下，我们只需要修改<code>output.filename</code>即可。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">output: {
  path: path.resolve(__dirname, &#39;dist/&#39;),
  filename: &#39;assets/[name].js&#39;
}
</code></pre>
<p>其次，我们将打包出来的<code>css</code>文件也放入<code>assets</code>路径下，因为我们打包<code>css</code>是使用<code>miniCssExtractPlugin</code>，因此我们只需要配置一下<code>miniCssExtractPlugin</code>的<code>filename</code>即可：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">plugins: [
  ...
  new miniCssExtractPlugin({
    filename: &#34;assets/[name].css&#34;
  })
]
</code></pre>
<p>最后就是静态资源了，这里我们使用静态模块方案，所以直接修改<code>output.assetModuleFilename</code>即可：</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">output: {
  path: path.resolve(__dirname, &#39;dist/&#39;),
  filename: &#39;assets/[name].js&#39;,
  assetModuleFilename: &#39;assets/[name][ext]&#39;
},
</code></pre>
<p>这时候打包一下，预览一下页面，发现都正常引入和使用。</p>
<h2>哈希值</h2>
<p>通常，我们打包文件的文件名都需要带上一个哈希值，这会给我们的好处就是避免缓存。</p>
<p><code>webpack</code>也提供了三种哈希值的策略，接下来我们一一来看看：</p>
<h3>前期准备</h3>
<p>为了更好的比较三者之间的区别，这边先调整一下项目和配置。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// index.js
import pic from &#34;../static/image.png&#34;;

const img = new Image();
img.src = pic;
document.querySelector(&#39;body&#39;).append(img);

// main.js
import &#34;../style/style.scss&#34;;
import &#34;../style/style.css&#34;;

console.log(&#39;Hello World&#39;)


// webpack.config.js
entry: {
  index: &#39;./src/js/index.js&#39;,
  main: &#39;./src/js/main.js&#39;
},
</code></pre>
<h3>hash策略</h3>
<p><code>hash</code>策略，是以项目为单位的，也就是说，只要项目一个文件发生改动，首先打包后该文件对应的<code>bundle</code>文件名会改变，其次所有<code>js</code>文件和<code>css</code>文件的文件名也会改变。</p>
<p>我们先通过一个例子来看看：</p>
<p>首先我们需要在所有设置<code>filename</code>的地方加入<code>[hash]</code>占位符，同时我们也可以设置哈希值的长度，只需加上冒号和长度值即可，比如<code>[hash:6]</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    entry: {
        index: &#39;./src/js/index.js&#39;,
        main: &#39;./src/js/main.js&#39;
    },
    output: {
        path: path.resolve(__dirname, &#39;dist/&#39;),
        filename: &#39;assets/[name]-[hash:6].js&#39;,
        assetModuleFilename: &#39;assets/[name]-[hash:6][ext]&#39;
    },
    module: {
        ...
    },
    plugins: [
        ...
        new miniCssExtractPlugin({
            filename: &#34;assets/[name]-[hash:6].css&#34;
        }),
    ]
};
</code></pre>
<p>这时候打包一下，看看打包文件：</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-7503bc.png
│   ├── index-7fa71a.js
│   ├── main-7fa71a.css
│   └── main-7fa71a.js
└── index.html
</code></pre>
<p>然后我随便改一下<code>style.css</code>，再重新打包一下。</p>
<p>这时候会发现<code>index.js</code>、<code>main.js</code>、<code>main.css</code>的文件名都会发生改变，但静态文件并不会发生变化。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-7503bc.png
│   ├── index-4b2329.js
│   ├── main-4b2329.css
│   └── main-4b2329.js
└── index.html
</code></pre>
<p>然后我们重新找一张图片，覆盖一下<code>image.png</code>，然后重新打包。</p>
<p>这时候，<code>index.js</code>、<code>main.js</code>、<code>main.css</code>的文件名依旧会发生改变，同时<code>image.png</code>也发生了变化。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-f3f2ec.png
│   ├── index-46acaa.js
│   ├── main-46acaa.css
│   └── main-46acaa.js
└── index.html
</code></pre>
<p>通过上面的例子，我们可以简单总结出：</p>
<ul>
<li>如果修改项目文件的话，所有的<code>js</code>、<code>css</code>打包文件的文件名都会发生变化，尽管来自多个<code>chunk</code>。</li>
<li>如果修改静态文件的话，该静态文件的打包文件文件名会发生变化，并且所有的<code>js</code>、<code>css</code>打包文件的文件名也都会发生变化。</li>
</ul>
<h3>chunkhash策略</h3>
<p>而<code>chunkhash</code>策略的话，是以<code>chunk</code>为单位的，如果一个文件发生变化，只有那条<code>chunk</code>相关的文件的打包文件文件名才会发生变化。</p>
<p>我们依旧通过例子看看：</p>
<p>首先我们先将配置文件都改成<code>chunkhash</code>。这里注意的是<code>chunkhash</code>不适用于静态文件，因此静态文件依旧使用<code>hash</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    entry: {
        index: &#39;./src/js/index.js&#39;,
        main: &#39;./src/js/main.js&#39;
    },
    output: {
        path: path.resolve(__dirname, &#39;dist/&#39;),
        filename: &#39;assets/[name]-[chunkhash:6].js&#39;,
        assetModuleFilename: &#39;assets/[name]-[hash:6][ext]&#39;
    },
    module: {
        ...
    },
    plugins: [
        ...
        new miniCssExtractPlugin({
            filename: &#34;assets/[name]-[chunkhash:6].css&#34;
        }),
    ]
};
</code></pre>
<p>先打包一次：</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-f3f2ec.png
│   ├── index-6be98e.js
│   ├── main-a15a74.css
│   └── main-a15a74.js
└── index.html
</code></pre>
<p>然后我们首先修改一下<code>style.css</code>，打包一下，会发现<code>main.css</code>和<code>main.js</code>都发生了变化，而<code>index.js</code>不是一个<code>chunk</code>的，因此不会发生变化。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-f3f2ec.png
│   ├── index-6be98e.js
│   ├── main-88f8ea.css
│   └── main-88f8ea.js
└── index.html
</code></pre>
<p>同样，我们再覆盖一下<code>image.png</code>，再打包一下。</p>
<p>这时候<code>image.png</code>固然会发生变化，然后<code>index.js</code>也发生了变化，因为它们是一个<code>chunk</code>的，而<code>main.css</code>和<code>main.js</code>就不会发生变化。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-7503bc.png
│   ├── index-89dfd4.js
│   ├── main-88f8ea.css
│   └── main-88f8ea.js
└── index.html
</code></pre>
<p>简单总结一下：</p>
<ul>
<li>如果修改项目文件的话，该项目文件对应的<code>chunk</code>的<code>js</code>、<code>css</code>打包文件的文件名都会发生变化。</li>
<li>如果修改静态文件的话，该静态文件的打包文件文件名会发生变化，并且引入该静态文件对应的<code>chunk</code>的<code>js</code>、<code>css</code>打包文件的文件名也都会发生变化。</li>
</ul>
<h3>contenthash策略</h3>
<p>最后一个就是<code>contenthash</code>策略， 它是以自身内容为单位的，因此当一个文件发生变化的时候，首先它本身的打包文件的名称会发生变化，其次，引入它的文件的打包文件也会发生变化。</p>
<p>惯例来个实验：</p>
<p>我们将所以哈希占位符改成<code>contenthash</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
    entry: {
        index: &#39;./src/js/index.js&#39;,
        main: &#39;./src/js/main.js&#39;
    },
    output: {
        path: path.resolve(__dirname, &#39;dist/&#39;),
        filename: &#39;assets/[name]-[contenthash:6].js&#39;,
        assetModuleFilename: &#39;assets/[name]-[contenthash:6][ext]&#39;
    },
    module: {
        ...
    },
    plugins: [
        ...
        new miniCssExtractPlugin({
            filename: &#34;assets/[name]-[contenthash:6].css&#34;
        }),
    ]
};
</code></pre>
<p>然后先打包一下。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-7503bc.png
│   ├── index-1e2b37.js
│   ├── main-02a4b4.css
│   └── main-c437b0.js
└── index.html
</code></pre>
<p>首先我们先修改一下图片吧，找一张新图覆盖一下<code>image.png</code>，然后打包一下。</p>
<p>首先<code>image.png</code>的名称一定会发生变化，因为它改动了。其次<code>index.js</code>也会发生变化，这是因为它引入了<code>image.png</code>，而<code>image.png</code>的名称发生变化，因此它代码中引入的名称也得发生变化，因此<code>index.js</code>的名称也会发生变化。</p>
<p>而<code>main.js</code>和<code>main.css</code>因为没有引用<code>image.png</code>，因此不会发生变化。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-f3f2ec.png
│   ├── index-e241d6.js
│   ├── main-02a4b4.css
│   └── main-c437b0.js
└── index.html
</code></pre>
<p>接下来，我们来修改一下<code>main.js</code>，然后打包一下。</p>
<p>我们会发现，只有<code>main.js</code>的打包文件会发生变化，而处于同个<code>chunk</code>的<code>main.css</code>却不会发生变化，这是因为<code>main.css</code>没有引用<code>main.js</code>。</p>
<pre><code class="hljs language-css copyable code-block-extension-codeShowNum">├── assets
│   ├── Alata-Regular-e83420.ttf
│   ├── image-f3f2ec.png
│   ├── index-e241d6.js
│   ├── main-02a4b4.css
│   └── main-d1f8ed.js
└── index.html
</code></pre>
<p>现在可以简单总结一下：</p>
<ul>
<li>不管是修改项目文件还是静态文件，它本身的打包文件的文件名会发生变化，其次引用该文件的对应打包文件的文件名也会发生变化，向上递归。</li>
</ul>
<h2>多个打包配置</h2>
<p>通常我们项目都会有开发环境和生产环境。</p>
<p>前面我们也看到了<code>webpack</code>提供了一个<code>mode</code>选项，但我们开发中不太可能说开发的时候<code>mode</code>设置为<code>development</code>，然后等到要打包才设置为<code>production</code>。当然，前面我们也说了，我们可以通过命令<code>--mode</code>来对应匹配<code>mode</code>选项。</p>
<p>但如果开发环境和生产环境的<code>webpack</code>配置差异不仅仅只有<code>mode</code>选项的话，我们可能需要考虑多份打包配置了。</p>
<h3>多个webpack配置文件</h3>
<p>我们默认的<code>webpack</code>配置文件名为<code>webpack.config.js</code>，而<code>webpack</code>执行的时候，也默认会找该配置文件。</p>
<p>但如果我们不使用该文件名，而改成<code>webpack.conf.js</code>的话，<code>webpack</code>正常执行是会使用默认配置的，因此我们需要使用一个<code>--config</code>选项，来指定配置文件。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">webpack --config webpack.conf.js
</code></pre>
<p>因此，我们就可以分别配置一个开发环境的配置<code>webpack.dev.js</code>和生成环境的配置<code>webpack.prod.js</code>，然后通过指令进行执行不同配置文件：</p>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">// package.json
 &#34;scripts&#34;: {
   &#34;dev&#34;: &#34;webpack --config webpack.dev.js&#34;,
   &#34;build&#34;: &#34;webpack --config webpack.prod.js&#34;,
 }
</code></pre>
<h3>单个配置文件</h3>
<p>如果说，你不想创建那么多配置文件的话，我们也可以只只用<code>webpack.config.js</code>来实现多份打包配置。</p>
<p>按照前面说的使用<code>--mode</code>配置<code>mode</code>选项，其实我们可以在<code>webpack.config.js</code>中拿到这个变量，因此我们就可以通过这个变量去返回不同的配置文件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// argv.mode可以获取到配置的mode选项
module.exports = (env, argv) =&gt; {
  if (argv.mode === &#39;development&#39;) {
    // 返回开发环境的配置选项
    return { ... }
  }else if (argv.mode === &#39;production&#39;) {
    // 返回生产环境的配置选项
    return { ... }
  }
};
</code></pre>
<h1>优化一下Webpack配置</h1>
<h2>合理的配置<code>mode</code>选项和<code>devtool</code>选项</h2>
<p>前面已经有讲到关于<code>mode</code>选项和<code>devtool</code>选项，而不同选项打包的速度也会有所不同，因此按照你的实际需求进行配置，有需要用到才生成，没需要用到就能省就省。</p>
<h2>缩小文件搜索范围</h2>
<h3>alias选项</h3>
<p>在配置文件中，其实有一个<code>resovle.alias</code>选项，它可以创建<code>import</code>和<code>reuquire</code>别名，来确保模块引入变得更简单，同时<code>webpack</code>在打包的时候也能更快的找到引入文件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// webpack.config.js
const path = require(&#39;path&#39;);

module.exports = {
  ...
  
  resolve: {
    alias: {
      // 配置style路径的别名
      style: path.resolve(__dirname, &#39;src/style/&#39;)
    },
  }
};
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// 使用
import &#34;style/style.scss&#34;;
import &#34;style/style.css&#34;;
</code></pre>
<h3>include、exclude选项</h3>
<p>当我们使用<code>loader</code>的时候，我们可以配置<code>include</code>来指定只解析该路径下的对应文件，同时我们可以配置<code>exclude</code>来指定不解析该路径下的对应文件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#39;path&#39;);

module.exports = {
  ...
  
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [miniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;],
        include: [path.resolve(__dirname, &#39;src&#39;)]  // 只解析src路径下的css
      }
      {
        test: /\.js$/,
        use: &#39;babel-loader&#39;,
        exclude: /node_modules/   // 不解析node_modules路径下的js
      }
  ]
}
};
</code></pre>
<h3>noParse选项</h3>
<p>我们可以在<code>module.noParse</code>选项中，只配置不需要解析的文件。通常我们会忽略一些大型插件从而来提高构建性能。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...
  module: {
    noParse: /jquery|lodash/,
  },
};
</code></pre>
<h2>使用HappyPack开启多进程Loader</h2>
<p>在<code>webpack</code>构建过程中，其实大部分消耗时间都是用到<code>loader</code>解析上面，一方面是因为转换文件数据量很大，另一方面是因为<code>JavaScript</code>单线程特性的原因，因此需要一个个去处理，而不能并发操作。</p>
<p>而我们可以使用<code>HappyPack</code>，将这部分任务分解到多个子进程中去进行并行处理，子进程处理完成后把结果发送到主进程中去，从而减少总的构建时间。</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack">github.com/amireh/happ…</a></p>
</blockquote>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 5.0.1
yarn add happypack -D
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// webpack.config.js
const HappyPack = require(&#34;happypack&#34;);
const os = require(&#34;os&#34;);
const HappyThreadPool = HappyPack.ThreadPool({size: os.cpus().length});

module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [{
          loader: &#39;happypack/loader?id=happyBabelLoader&#39;
        }]
      }
    ]
  },
  plugins: [
    new HappyPack({
      id: &#39;happyBabelLoader&#39;,  // 与loader对应的id标识
      // 用法跟loader配置一样
      loaders: [
        {loader: &#39;babel-loader&#39;, options: {}}
      ],
      threadPool: HappyThreadPool  // 共享进程池
    })
  ]
};
</code></pre>
<h2>使用webpack-parallel-uglify-plugin 增强代码压缩</h2>
<p>起码有聊到，当<code>mode</code>为<code>production</code>的时候，<code>webpack</code>打包会开启代码压缩插件，同时<code>webpack</code>也有提供一个<code>optimization</code>选项，让我们可以使用自己喜欢的插件去覆盖原生插件。</p>
<p>因此，我们可以使用<code>webpack-parallel-uglify-plugin</code>来覆盖原生代码压缩插件，它的一个优点就是可以并行执行。</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgdborton%2Fwebpack-parallel-uglify-plugin%23readme">github.com/gdborton/we…</a></p>
</blockquote>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 2.0.0
yarn add webpack-parallel-uglify-plugin -D
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// webpack.config.js
const ParallelUglifyPlugin = require(&#34;webpack-parallel-uglify-plugin&#34;)

module.exports = {
  ...
  
  optimization: {
    minimizer: [
      new ParallelUglifyPlugin({
        // 缓存路径
        cacheDir: &#39;.cache/&#39;,  
        // 压缩配置
        uglifyJS: {
          output: {
            comments: false,
            beautify: false
          },
          compress: {
            drop_console: true,
            collapse_vars: true,
            reduce_vars: true
          }
        }
      })
    ]
  }
};
</code></pre>
<h2>配置缓存</h2>
<p>我们每次执行构建都会把所有的文件都重新编译一边，如果我们可以将这些重复动作缓存下来的话，对下一步的构建速度会有很大的帮助。</p>
<p>现在大部分的<code>loader</code>都提供了缓存选项，但并非所有的<code>loader</code>都有，因此我们最好自己去配置一下全局的缓存动作。</p>
<p>在<code>Webpack5</code>之前，我们都使用了<code>cache-loader</code>，而在<code>webpack5</code>中，官方提供了一个<code>cache</code>选项给我们带来持久性缓存。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// 开发环境
module.exports = {
  cache: {
    type: &#39;memory&#39;  // 默认配置
  }
}

// 生产环境
module.exports = {
  cache: {
    type: &#39;filesystem&#39;,
    buildDependencies: {
      config: [__filename]
    }
  }
}
</code></pre>
<h2>分析打包文件大小</h2>
<p>我们可以使用<code>webpack-bundle-analyzer</code>插件来帮助我们分析打包文件，它会将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容。</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fwebpack-bundle-analyzer">github.com/webpack-con…</a></p>
</blockquote>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 4.4.2
yarn add webpack-bundle-analyzer -D
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// webpack.config.js
const {BundleAnalyzerPlugin} = require(&#39;webpack-bundle-analyzer&#39;);

module.exports = {
    ...
  
    plugins: [
        new BundleAnalyzerPlugin()
    ]
};
</code></pre>
<p>然后我们打包后，<code>webpack</code>会自动打开一个页面，显示我们打包文件的情况，通过打包报告可以很直观的知道哪些依赖包大，则可以做做针对性的修改。</p>
<p><img src="https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/249ea785.webp"/></p>
<p>如果不想每次运行都打开网页的话，我们可以先将数据保存起来，然后要看的时候再执行新的命令去查看。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// webpack.config.js
new BundleAnalyzerPlugin({
   analyzerMode: &#39;disabled&#39;,
   generateStatsFile: true
 })
</code></pre>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">// package.json
&#34;scripts&#34;: {
  &#34;analyzer&#34;: &#34;webpack-bundle-analyzer --port 3000 ./dist/stats.json&#34;
},
</code></pre>
<h1>手写一下</h1>
<h2>手写Loader</h2>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fcontribute%2Fwriting-a-loader%2F%23common-code">webpack.js.org/contribute/…</a></p>
</blockquote>
<p>在<code>webpack</code>官网，它给提出了几个<code>loader</code>的编写原则：</p>
<ul>
<li>**单一原则：**每个<code>loader</code>只做一件事情；</li>
<li><strong>链式调用：</strong><code>webpack</code>会按照顺序链式去调用每个<code>loader</code>；</li>
<li>**统一原则：**遵循<code>webpack</code>定制的设计规则和结构，输入和输入均为字符串，每个<code>loader</code>完全独立，即插即用。</li>
</ul>
<p>同时<code>webpack</code>还给我们提供了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Floaders%2F"><code>loader API</code></a>，因此我们可以使用<code>this</code>去获取需要用到的<code>API</code>，但也是因为如此，我们<code>loader</code>的实现就<strong>不能使用箭头函数</strong>了。</p>
<p>今天，我们来简单手写一下<code>sass-loader</code>、<code>css-loader</code>和<code>style-loader</code>，而它们也有各自的单一功能：</p>
<ul>
<li><code>sass-loader</code>：用来解析<code>sass</code>和<code>scss</code>代码；</li>
<li><code>css-loader</code>：用来解析<code>css</code>代码；</li>
<li><code>style-loader</code>：将<code>css</code>代码插入到<code>js</code>中。</li>
</ul>
<p>首先，我们先创建一个<code>myLoders</code>文件夹，然后创建三个<code>loader</code>文件。</p>
<pre><code class="hljs copyable code-block-extension-codeShowNum">├── myLoaders
│   ├── ou-css-loader.js
│   ├── ou-sass-loader.js
│   └── ou-style-loader.js
</code></pre>
<p>然后我们需要在<code>webpack</code>引入，并且需要配置一下<code>resolveLoader</code>选项，因为<code>webpack</code>默认只会去<code>node_modules</code>搜索<code>loader</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = {
  ...

  resolveLoader: {
    // 添加loader查询路径
    modules: [&#39;node_modules&#39;, &#39;./myLoaders&#39;]
  },
  module: {
    rules: [{
      test: /\.(scss|sass)$/,
      // 使用自己的loader
      use: [&#39;ou-style-loader&#39;,&#39;ou-css-loader&#39;,&#39;ou-sass-loader&#39;]
    }]
  }
};
</code></pre>
<p>首先我们先来实现<code>ou-sass-loader</code>。</p>
<p><code>loader</code>的本质就是一个函数，而我们可以在函数的第一个参数获取到对应文件的代码，我们可以先打印一下来看看。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// ou-sass-loader.js
module.exports = function(source) {
  console.log(source);
}
</code></pre>
<p>然后执行打包后，我们可以看到我们的<code>scss</code>文件中的代码。</p>
<p>因此，我们可以使用<code>sass</code>插件来进行解析<code>scss</code>代码，<code>sass</code>有一个<code>render</code>函数可以去解析。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// ou-sass-loader.js
const sass = require(&#39;sass&#39;);

module.exports = function(source) {
  // 使用render函数进行解析scss代码
  sass.render({data: source},  (err, result) =&gt; {
    console.log(result);
  });
}
</code></pre>
<p>我们在执行一下打包，会发现<code>result</code>是一个对象，而里面的<code>css</code>就是我们所需要的，因此我们需要将其返回出去。</p>
<blockquote>
<p>这里<code>css</code>是<code>Buffer</code>，我们需要去解析它，但是解析它是<code>css-loader</code>的工作，而不是<code>sass-loader</code>的工作。</p>
</blockquote>
<pre><code class="hljs language-json copyable code-block-extension-codeShowNum">{
  css: ,
  map: null,
  stats: {
    entry: &#39;data&#39;,
    start: 1628131813793,
    end: 1628131813830,
    duration: 37,
    includedFiles: [ [Symbol($ti)]: [Rti] ]
  }
}
</code></pre>
<p>但这里是一个异步操作，我们不能直接<code>return</code>回去，而是需要使用到<code>webpack</code>提供的一个<code>API</code>——<code>this.async</code>，它本身是一个函数，然后会返回一个<code>callback()</code>让我们可以返回异步的结果。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// ou-sass-loader.js
const sass = require(&#39;sass&#39;);

module.exports = function(source) {
  // 获取callback函数
  const callback = this.async();
  sass.render({data: source},  (err, result) =&gt; {
    // 将结果返回
    if (err) return callback(err);
    callback(null, result.css);
  });
}
</code></pre>
<p>这时候，我们<code>ou-sass-loader</code>就实现了，接下来我们来实现<code>ou-css-loader</code>。</p>
<p>它其实任务很简单，就是将<code>ou-sass-loader</code>返回的<code>css</code>解析为字符串就可以了。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// ou-css-loader.js
module.exports = function(source) {
    return JSON.stringify(source)
}
</code></pre>
<p>最后就是<code>ou-style-loader</code>，它的任务就是创建一个<code>style</code>标签，然后将<code>ou-css-loader</code>返回的数据插进去，并且将<code>style</code>标签放置到<code>head</code>标签里面去。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// ou-style-loader.js
module.exports = function(sources) {
    return `
        const tag = document.createElement(&#34;style&#34;);
        tag.innerHTML = ${sources};
        document.head.appendChild(tag)
    `
}
</code></pre>
<p>这时我们简易版的<code>sass-loader</code>、<code>css-laoder</code>和<code>style-laoder</code>就实现了，我们可以执行一下打包命令，检验页面是不是有对应的样式效果。</p>
<h2>手写Plugin</h2>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fcontribute%2Fwriting-a-plugin%2F">webpack.js.org/contribute/…</a></p>
</blockquote>
<p>在<code>webpack</code>运行过程中，会存在一个生命周期，而在生命周期中<code>webpack</code>会广播出许多事情，而在<code>plugin</code>中是可以监听到这些事件，因此<code>plugin</code>是可以实现在合适的时机通过<code>Webpack</code>提供的<code>API</code>去实现一些动作。</p>
<p>正常情况下，一个<code>plugin</code>是一个类，并且里面会有一个<code>apply</code>函数，而在<code>apply</code>函数中会接收到一个<code>compiler</code>参数，里面包含了关于<code>webpack</code>环境所有的配置信息。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = class MyPlugin {
  apply (compiler) {}
}
</code></pre>
<p>在<code>compiler</code>中会暴露很多生命周期钩子函数，具体的可以查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcompiler-hooks%2F">文档</a>。我们可以通过以下方式去访问钩子函数。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">compiler.hooks.someHook.tap(...)
</code></pre>
<p>在<code>tap</code>方法中，接收两个参数，一个是该<code>plugin</code>的名称，一个是回调函数，而在回调函数中，又会接收到一个<code>compilation</code>参数。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = class MyPlugin {
  apply (compiler) {
    compiler.hooks.compile.tap(&#34;MyPlugin&#34;, (compilation) =&gt; {
      console.log(compilation)
    })
  }
}
</code></pre>
<p><code>compilation</code>对象包含了当前的模块资源、编译生成资源、变化的文件等。当运行<code>webpack</code> 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code>，从而生成一组新的编译资源。<code>compilation</code> 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>
<p><code>compliation</code>也暴露了许多的钩子，具体的话可以去看看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcompilation-hooks%2F">文档</a>。</p>
<p>接下来，简单实现一下一个<code>plugin</code>，打包后生成一个<code>txt</code>文件，里面会打印出每个<code>bundle</code>的大小。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = class MyPlugin {
  apply(compiler) {
    // 生成资源到 output 目录之前
    compiler.hooks.emit.tap(&#34;MyPlugin&#34;, (compilation) =&gt; {
      let str = &#39;&#39;
      for (let filename in compilation.assets) {
        // 获取文件名称和文件大小
        str += `${filename} -&gt; ${compilation.assets[filename][&#39;size&#39;]() / 1000}KB\n`
      }

      // 新建fileSize.txt
      compilation.assets[&#39;fileSize.txt&#39;] = {
        // 内容
        source: function () {
          return str
        }
      }
    })
  }
}
</code></pre>
<p>紧接着，我们将其引入到<code>webpack.config.js</code>，并在<code>plugins</code>中创建实例。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const MyPlugin = require(&#34;./myPlugins/my-plugin&#34;)

module.exports = {
    ...
  
    plugins: [
        new MyPlugin()
    ]
};
</code></pre>
<p>然后打包后，<code>dist</code>文件中会生成一个<code>fileSize.txt</code>文件。</p>
<pre><code class="hljs language-rust copyable code-block-extension-codeShowNum">assets/Alata-Regular-e83420.ttf -&gt; 96.208KB
assets/image-f3f2ec.png -&gt; 207.392KB
index.html -&gt; 0.364KB
assets/index-41f0e2.css -&gt; 0.177KB
assets/index-acc2f5.js -&gt; 1.298KB
</code></pre>
<h2>手写Webpack</h2>
<blockquote>
<p>代码：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fouduidui%2Fmini-webpack">github.com/ouduidui/mi…</a></p>
<p>喜欢的朋友可以点个<code>Star</code>哦~</p>
</blockquote>
<h3>初始化</h3>
<p>首先我们先初始化我们的项目文件。</p>
<p>先新建一个<code>src</code>路径，然后创建三个<code>js</code>文件——<code>index.js</code>、<code>a.js</code>、<code>b.js</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// index.js
import {msg} from &#34;./a.js&#34;;

console.log(msg);



// a.js
import {something} from &#34;./b.js&#34;;

export const msg = `Hello ${something}`;


// b.js
export const something = &#39;World&#39;;
</code></pre>
<p>然后我们可以先安装<code>webpack</code>，然后测试一下打包出来的<code>bundle</code>文件有什么特点。</p>
<blockquote>
<p>这里就不多说了，直接看<code>bundle</code>文件（默认配置，<code>mode</code>为<code>development</code>）</p>
</blockquote>
<p>打包后，我们可以看到<code>bundle</code>文件有很多内容，但也有一大半注释。</p>
<p>其实我们只需要看两个地方，一个是<code>__webpack_modules__</code>变量。我们可以看到它是一个对象，然后<code>key</code>值为<code>module</code>路径，而<code>value</code>值是执行<code>module</code>代码的函数。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">var __webpack_modules__ = ({
  &#34;./src/a.js&#34;: (() =&gt; eval( ... )),
  &#34;./src/b.js&#34;: (() =&gt; eval( ... )),
  &#34;./src/index.js&#34;: (() =&gt; eval( ... ))
})
</code></pre>
<p>其次，我们能看到一个函数，叫<code>__webpack_require__</code>，它接收一个<code>moduleId</code>的参数。然而我们可以在最后看到了这个函数的调用，就会发现其实<code>moduleId</code>就是<code>__webpack_modules__</code>的<code>key</code>值，也就是<code>module</code>的路径。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">var __webpack_exports__ = __webpack_require__(&#34;./src/index.js&#34;);
</code></pre>
<p>到这里，我们就可以大概捋清楚<code>webpack</code>打包的一个逻辑了。</p>
<ul>
<li><code>webpack</code>是直接拿到<code>js</code>文件的代码，即字符串。然后通过<code>eval()</code>函数执行代码；</li>
<li><code>webpack</code>会从入口文件开始，不断递归遍历引入模块，然后保持在一个对象里面，<code>key</code>值为<code>moduleId</code>，即模块路径，而<code>value</code>是模块的相关代码。</li>
<li><code>webpack</code>会将代码转换为<code>commonJS</code>，即使用<code>require</code>去引入模块，同时它自身会去封装一个<code>require</code>函数，去执行入口文件代码。</li>
</ul>
<p>话不多说，我们开始来手写代码。</p>
<p>首先我们可以先初始化<code>webpack</code>配置文件——<code>webpack.config.js</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const path = require(&#34;path&#34;);

module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: {
    path: path.resolve(__dirname, &#34;./dist&#34;),
    filename: &#39;index.js&#39;
  }
}
</code></pre>
<p>其次，我们新建一个<code>lib</code>文件夹，然后创建一个<code>webpack.js</code>，用来手写我们的<code>mini-webpack</code>。</p>
<p>我们可以先初始化一下，<code>Webpack</code>是一个类，其次构建函数会接受配置文件，其次会有一个<code>run</code>函数，是<code>webpack</code>的运行函数。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = class Webpack {
  /**
  *  构造函数，获取webpack配置
  *  @param {*} options
  */
  constructor(options) {}

  /**
  *  webpack运行函数
  */
  run() {
    console.log(&#39;开始执行Webpack!&#39;)
  }
}
</code></pre>
<p>然后我们需要一个执行文件，即在根路径创建一个<code>debugger.js</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const webpack = require(&#39;./lib/webpack&#39;);
const options = require(&#39;./webpack.config&#39;);

new webpack(options).run();
</code></pre>
<p>紧接着我们执行一下该文件。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">node debugger.js
</code></pre>
<p>这时候命令行就会打印出<code>开始执行Webpack!</code>。</p>
<p>我们可以开始手写<code>mini-webpack</code>了。</p>
<h3>模块解析</h3>
<p>首先，在构造函数中，我们需要保存一下配置信息。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">constructor(options) {
  const {entry, output} = options;
  this.entry = entry;  // 入口文件
  this.output = output;  // 导出配置
}
</code></pre>
<p>在执行的第一步，我们需要来解析一下入口文件，因此我们用一个<code>parseModules</code>来实现这个功能。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">module.exports = class Webpack {
    constructor(options) {
        ...
    }

    run() {
        // 解析模块
        this.parseModules(this.entry);
    }

    /**
     *  模块解析
     *  @param {*} file
     */
    parseModules(file) {}
}
</code></pre>
<p>在<code>parseModules</code>中，我们需要做两件事情：分析模块信息、递归遍历引入模块。</p>
<p>我们一步一步来实现。首先，封装一个<code>getModuleInfo</code>函数，来分析模块信息。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">parseModules(file) {
  // 分析模块
  this.getModuleInfo(file);
}

 /**
 *  分析模块
 *  @param {*} file
 *  @returns Object
 */
getModuleInfo(file) {}
</code></pre>
<p>首先，我们接收到的<code>file</code>其实就是入口文件的相对路径，即<code>./src/index.js</code>。因此我们可以先用<code>node</code>自带的<code>fs</code>模块来读取文件内容。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">getModuleInfo(file) {
  // 读取文件
  const body = fs.readFileSync(file, &#34;utf-8&#34;);
}
</code></pre>
<p>读取到内容后，我们就要来分析一下文件内容了，这时候就需要用到了<code>AST语法树</code>了。</p>
<blockquote>
<p>抽象语法树 (<code>Abstract Syntax Tree</code>)，简称 <code>AST</code>，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>演示地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F">astexplorer.net/</a></p>
</blockquote>
<p>这里我们用到的时候<code>babel</code>的<code>parse</code>插件，通过它来将<code>JavaScript</code>转成<code>AST</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 7.14.8
yarn add @babel/parser -D
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const fs = require(&#34;fs&#34;);
const parser = require(&#34;@babel/parser&#34;);

module.exports = class Webpack {
    ...

    getModuleInfo(file) {
      // 读取文件
      const body = fs.readFileSync(file, &#34;utf-8&#34;);

      // 转化为AST语法树
      const ast = parser.parse(body, {
        sourceType: &#39;module&#39;  // 表示我们解析的是ES模块
      })
    }
}
</code></pre>
<p>紧接着，我们还需要使用<code>@babel/traverse</code>来遍历<code>AST</code>，从而来识别该文件有没有引入其他模块，有的话就将其记录下来。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># 7.14.8
yarn add @babel/traverse -D
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const traverse = require(&#34;@babel/traverse&#34;).default;
</code></pre>
<p><code>traverse</code>接受两个参数，第一个是<code>ast</code>语法树，第二个是一个对象，在对象中我们可以设置观察者函数，并且可以针对语法树中的特定节点类型。</p>
<p>比如我们这次只需要找到引入模块的语句，对应的节点类型为<code>ImportDeclaration</code>，我们就可以设置对应的<code>ImportDeclaration</code>函数，并在参数值获取到节点信息。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const fs = require(&#34;fs&#34;);
const path = require(&#34;path&#34;);
const parser = require(&#34;@babel/parser&#34;);
const traverse = require(&#34;@babel/traverse&#34;).default;


module.exports = class Webpack {
    ...

    getModuleInfo(file) {
      // 读取文件
      const body = fs.readFileSync(file, &#34;utf-8&#34;);

      // 转化为AST语法树
      const ast = parser.parse(body, {
        sourceType: &#39;module&#39;  // 表示我们解析的是ES模块
      })
      
      traverse(ast, {
        // visitor函数
        ImportDeclaration({node}) {
          console.log(node);
        }
      })
    }
}
</code></pre>
<p>我们执行一下，可以打印出<code>import {msg} from &#34;./a.js&#34;</code>的语法树。</p>
<p>因此，我们需要将其路径收集起来。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">// 依赖收集
const deps = {};
traverse(ast, {
  // visitor函数
  ImportDeclaration({node}) {
    // 入口文件路径
    const dirname = path.dirname(file);
    // 引入文件路径
    const absPath = &#34;./&#34; + path.join(dirname, node.source.value);
    deps[node.source.value] = absPath;
  }
})
</code></pre>
<p>此时的<code>deps</code>就是<code>{ &#39;./a.js&#39;: &#39;./src/a.js&#39; }</code>，之所以要保存它相对项目根路径的相对路径，是为了后面更好的去拿到它的文件内容。</p>
<p>收集完依赖后，我们需要将<code>AST</code>转回<code>JavaScript</code>代码，并且将其转成<code>ES5</code>语法。这时候我们就会用到<code>@babel/core</code>和<code>@babel/preset-env</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum"># @babel/core -&gt; 7.14.8, @babel/preset-env -&gt; 7.14.8
yarn add @babel/core @babel/preset-env -D
</code></pre>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">const fs = require(&#34;fs&#34;);
const path = require(&#34;path&#34;);
const parser = require(&#34;@babel/parser&#34;);
const traverse = require(&#34;@babel/traverse&#34;).default;
const babel = require(&#34;@babel/core&#34;);

module.exports = class Webpack {
    ...

    getModuleInfo(file) {
      // 读取文件
      const body = fs.readFileSync(file, &#34;utf-8&#34;);

      // 转化为AST语法树
      const ast = parser.parse(body, {
        sourceType: &#39;module&#39;  // 表示我们解析的是ES模块
      })
      
      // 依赖收集
      const deps = {};
      traverse(ast, {
        // visitor函数
        ImportDeclaration({node}) {
          // 入口文件路径
          const dirname = path.dirname(file);
          // 引入文件路径
          const absPath = &#34;./&#34; + path.join(dirname, node.source.value);
          deps[node.source.value] = absPath;
        }
      })

      // ES6转成ES5
      const {code} = babel.transformFromAst(ast, null, {
        presets: [&#34;@babel/preset-env&#34;],
      })
    }
}
</code></pre>
<p>这时候我们可以打印一下<code>code</code>，会发现它不再是<code>ESModule</code>的引入方式了，而是使用了<code>CommonJS</code>引入方式。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">&#34;use strict&#34;;

var _a = require(&#34;./a.js&#34;);

console.log(_a.msg);
</code></pre>
<p>最终，<code>getModuleInfo</code>会返回一个对象，对象里面包含着解析文件的路径，该文件的依赖对象以及文件代码。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">parseModules(file) {
  // 分析模块
  const entry = this.getModuleInfo(file);
}

getModuleInfo(file) {
  ...

  return {
    file,   // 文件路径
    deps,  // 依赖对象
    code   // 代码
  };
}
</code></pre>
<p>但我们分析完入口文件后，我们就需要进行递归遍历，去分析引入模块。</p>
<p>首先，我们需要新建一个数组，保存一下所有的分析结果。其次，我们来实现一下<code>getDeps</code>函数，来递归遍历引入模块。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">parseModules(file) {
  // 分析模块
  const entry = this.getModuleInfo(file);
  const temp = [entry];

  // 递归遍历，获取引入模块代码
  this.getDeps(temp, entry)
}


/**
 * 获取依赖
 *  @param {*} temp
 *  @param {*} module
*/
getDeps(temp, {deps}) {}
</code></pre>
<p>在<code>getDeps</code>中，我们可以通过第二个参数获取到依赖对象，其次通过遍历这个对象，一一执行一下<code>getModuleInfo</code>函数，获取各个依赖模块的解析内容，并保存到<code>temp</code>。</p>
<p>最后，再自调用一下<code>getDeps</code>，传入引入模块内容，继续递归遍历。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">getDeps(temp, {deps}) {
  // 遍历依赖
  Object.keys(deps).forEach(key =&gt; {
    // 获取依赖模块代码
    const child = this.getModuleInfo(deps[key]);
    temp.push(child);
    // 递归遍历
    this.getDeps(temp, child);
  })
}
</code></pre>
<p>这里还需要进行查重，比如在多个文件都引入了<code>b.js</code>的话，<code>temp</code>数组就会保存多个<code>b.js</code>的内容对象，因此我们可以先查重一下，如果<code>temp</code>对象没有该模块，我们再执行后面的操作。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">getDeps(temp, {deps}) {
  Object.keys(deps).forEach(key =&gt; {
    // 去重
    if (!temp.some(m =&gt; m.file === deps[key])) {
      const child = this.getModuleInfo(deps[key]);
      temp.push(child);
      this.getDeps(temp, child);
    }
  })
}
</code></pre>
<p>这时候，我们模块解析的操作已经完成了差不多了。</p>
<p>最后我们最需要将<code>temp</code>数组，转换成对象，即跟<code>__webpack_modules__</code>类似，以路径为<code>key</code>名，然后<code>value</code>为对应的内容信息。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">parseModules(file) {
  const entry = this.getModuleInfo(file);
  const temp = [entry];

  this.getDeps(temp, entry)

  // 将temp转成对象
  const depsGraph = {};
  temp.forEach(moduleInfo =&gt; {
    depsGraph[moduleInfo.file] = {
      deps: moduleInfo.deps,
      code: moduleInfo.code
    }
  })

  return depsGraph;
}
</code></pre>
<p>这时候，我们在<code>run()</code>函数保存一下解析结果，就完成了第一步操作了。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">run() {
  // 解析模块
  this.depsGraph = this.parseModules(this.entry);
}
</code></pre>
<h3>打包</h3>
<p>下一步就是执行打包操作了，我们先封装一个<code>bundle</code>函数。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">run() {
  // 解析模块
  this.depsGraph = this.parseModules(this.entry);

  // 打包
  this.bundle()
}

/**
*  生成bundle文件
*/
bundle() { }
</code></pre>
<p>首先我们先把简单的部分完成了，就是生成打包文件。</p>
<p>我们要用到<code>fs</code>模块，先识别打包路径存不存在，不存在的话新建一个目录，其次就写入<code>bundle</code>文件。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">bundle() {
  const content = `console.log(&#39;Hello World&#39;)`;

  // 生成bundle文件
  !fs.existsSync(this.output.path) &amp;&amp; fs.mkdirSync(this.output.path);
  const filePath = path.join(this.output.path, this.output.filename);
  fs.writeFileSync(filePath, content);
}
</code></pre>
<p>这时运行一下打包命令，项目里就会出现一个<code>dist</code>文件夹，里面会有一个<code>index.js</code>。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">console.log(&#39;Hello World&#39;)
</code></pre>
<p>接下来我们就得来实现<code>bundle</code>文件的内容。</p>
<p>首先它是一个匿名函数只执行的方式，然后它接收一个参数<code>__webpack_modules__</code>，即我们前面解析文件的结果。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">(function(__webpack_modules__){
  ...
})(this.depsGraph)
</code></pre>
<p>其次，我们需要是实现一下<code>__webpack_require__</code>函数，它接收一个<code>moduleId</code>参数，即路径参数。</p>
<p>然后我们还需要去调用一下<code>__webpack_require__</code>，并传入入口文件路径。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">(function(__webpack_modules__){
  function __webpack_require__(moduleId) {
    ...
  }
  __webpack_require__(this.entry)  
})(this.depsGraph)
</code></pre>
<p>前面我们又看到，<code>babel</code>将代码转义成<code>commonJS</code>，因此我们需要来实现一下<code>require</code>函数，因为<code>JavaScript</code>本身不具备。</p>
<p><code>require</code>函数的实质就是返回引入文件的内容。</p>
<p>同时，我们还需要新建一个<code>exports</code>对象，这样子模块导出的内容就可以保存到里面去了，最后也需要将其返回出去。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">(function(__webpack_modules__){
  function __webpack_require__(moduleId) {
    // 实现require方法
    function require(relPath) {
      return __webpack_require__(__webpack_modules__[moduleId].deps[relPath])
    }
    // 保存导出模块
    var exports = {};
    
    return exports
  }
  __webpack_require__(this.entry)  
})(this.depsGraph)
</code></pre>
<p>最后，就只需要来执行一下入口文件的代码即可。</p>
<p>这里还是使用一个匿名函数并自调用。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">(function(__webpack_modules__){
  function __webpack_require__(moduleId) {
    // 实现require方法
    function require(relPath) {
      return __webpack_require__(__webpack_modules__[moduleId].deps[relPath])
    }
    // 保存导出模块
    var exports = {};
    
    // 调用函数
    (function (require,exports,code) {
      eval(code)
    })(require,exports,__webpack_modules__[moduleId].code)
    
    return exports
  }
  __webpack_require__(this.entry)  
})(this.depsGraph)
</code></pre>
<p>这时候我们再将这段代码，换到<code>content</code>变量中去。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">bundle() {
  const content = `
    (function (__webpack_modules__) {
      function __webpack_require__(moduleId) {
        function require(relPath) {
          return __webpack_require__(__webpack_modules__[moduleId].deps[relPath])
          }
          var exports = {};
          (function (require,exports,code) {
            eval(code)
          })(require,exports,__webpack_modules__[moduleId].code)
          return exports
        }
        __webpack_require__(&#39;${this.entry}&#39;)
    })(${JSON.stringify(this.depsGraph)})
  `;

  // 生成bundle文件
  !fs.existsSync(this.output.path) &amp;&amp; fs.mkdirSync(this.output.path);
  const filePath = path.join(this.output.path, this.output.filename);
  fs.writeFileSync(filePath, content);
}
</code></pre>
<p>然后执行打包，就可以看到完整的打包内容了。</p>
<pre><code class="hljs language-javascript copyable code-block-extension-codeShowNum">(function (__webpack_modules__) {
    function __webpack_require__(moduleId) {
        function require(relPath) {
            return __webpack_require__(__webpack_modules__[moduleId].deps[relPath])
        }
        var exports = {};
        (function (require,exports,code) {
            eval(code)
        })(require,exports,__webpack_modules__[moduleId].code)
        return exports
    }
    __webpack_require__(&#39;./src/index.js&#39;)
})({&#34;./src/index.js&#34;:{&#34;deps&#34;:{&#34;./a.js&#34;:&#34;./src/a.js&#34;},&#34;code&#34;:&#34;\&#34;use strict\&#34;;\n\nvar _a = require(\&#34;./a.js\&#34;);\n\nconsole.log(_a.msg);&#34;},&#34;./src/a.js&#34;:{&#34;deps&#34;:{&#34;./b.js&#34;:&#34;./src/b.js&#34;},&#34;code&#34;:&#34;\&#34;use strict\&#34;;\n\nObject.defineProperty(exports, \&#34;__esModule\&#34;, {\n  value: true\n});\nexports.msg = void 0;\n\nvar _b = require(\&#34;./b.js\&#34;);\n\nvar msg = \&#34;Hello \&#34;.concat(_b.something);\nexports.msg = msg;&#34;},&#34;./src/b.js&#34;:{&#34;deps&#34;:{},&#34;code&#34;:&#34;\&#34;use strict\&#34;;\n\nObject.defineProperty(exports, \&#34;__esModule\&#34;, {\n  value: true\n});\nexports.something = void 0;\nvar something = &#39;World&#39;;\nexports.something = something;&#34;}})

</code></pre>
<p>最后，我们执行一下，看看能不能打印出<code>Hello World</code>。</p>
<pre><code class="hljs language-shell copyable code-block-extension-codeShowNum">node ./dist/index.js
</code></pre></div></div></article></div></div></main></div></div></div></div>
      <hr/>
      <!-- clipping information -->
      </main>
<footer>
        <label>原网址: <a href="https://juejin.cn/post/6994346951739179039" target="_blank" referrerpolicy="no-referrer" rel="noopener noreferrer">访问</a></label><br/>
        <label>创建时间: 2023-05-14 16:14:05</label><br/>
        <br/>
        
      </footer>
</body>
</html>