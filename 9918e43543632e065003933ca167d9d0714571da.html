<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React-Server-Components手把手教学</title>
    <link rel="stylesheet" href="https://c1312.netlify.app/typo.css">
    <link rel="stylesheet" href="https://c1312.netlify.app/style.css">
</head>
<body>
<header>
  <h1>React-Server-Components手把手教学</h1>
</header>
<main class="typo"><div><section><h1><span>前言</span></h1><p>在上一篇介绍<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU2OTE1Mw==&amp;mid=2247489443&amp;idx=1&amp;sn=c0f50860bd01765929dc24c95e1ab898&amp;scene=21#wechat_redirect">React 18 如何提升应用性能</a>文章中提到了很多关于<code>React</code>性能优化的方式,例如(<code>Suspence</code>),从底层实现的角度来看,都是基于<code>React Server Component</code>(简称<code>RSC</code>)来做文章.<p>在<code>2020</code>年末，<code>React</code>团队引入了<code>Zero-Bundle-Size React Server Components</code>概念。自那以后，<code>React</code>开发者社区一直在尝试并学习如何应用这种前瞻性的方法。<p><code>React</code>改变了我们构建用户界面的思维方式。而使用<code>RSC</code>的新模型更加结构化、方便、可维护，并提供了更好的用户体验。<p>最新版本的<code>Next.js 13</code>已经采用了<strong>「以服务器组件思维方式」</strong>,并将其作为<strong>「默认选项」</strong>。作为<code>React</code>开发者，我们必须适应这种新的思维模式，以充分发挥其在构建应用程序方面的优势。<blockquote><span>❝</span><p><code>RSC</code>很好的将<code>服务器端渲染</code>与<code>客户端JavaScript的交互性</code>无缝地融合在一起。</p><span>❞</span></blockquote><p>所以,我们有必要用一篇文章来介绍它.(文章有点长,请耐心观看,并且内容有点内核,配合收藏观看更佳)<h3><span>你能所学到的知识点</span></h3><blockquote><span>❝</span><ol><li><section>前置知识点</section><li><section>React :客户端UI库</section><li><section>React 应用的通病</section><li><section>SSR 和 Suspense 解决的痛点</section><li><section>客户端-服务器模型</section><li><section>RSC的红与黑</section><li><section>如何同时使用客户端组件和服务器组件</section><li><section>RSC的优点</section></ol><span>❞</span></blockquote><p>好了，天不早了，干点正事哇。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/55d051c1.gif></figure><hr><h1><span>1. 前置知识点</span></h1><h2><span>网络瀑布效应</span></h2><p>网络瀑布效应（<code>Network Waterfall Effect</code>）是一个用于描述在<code>计算机网络</code>中出现的性能问题的概念。它通常用来说明在复杂的网络环境中，一个小问题的出现可能会逐渐扩大，导致整个网络的性能下降。(类似<strong>「多米诺骨牌」</strong>一样)<blockquote><span>❝</span><p>网络瀑布效应的核心思想是，<strong>「网络中的各个组件和节点之间相互依赖，一个组件的问题可能会影响到其他组件，从而引发连锁反应」</strong>。</p><span>❞</span></blockquote><p>这种效应通常在<code>大规模、分布式</code>的网络中更为显著，因为网络中的节点众多，问题的传播速度和范围都会加大。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/5cc86c03.webp></figure><blockquote><span>❝</span><p>这意味着后续的获取请求仅在前一个获取请求被解析或完成后才会被初始化。</p><span>❞</span></blockquote><hr><h2><span>水合(<code>Hydration</code>)</span></h2><p>在计算机科学领域，<code>水合</code>（<code>Hydration</code>）通常指的是<strong>「将数据或状态从一种格式或状态转换为另一种格式或状态的过程」</strong>。<h3><span>React/Vue 水合</span></h3><p><code>React</code>和<code>Vue</code>的水合流程大差不差(反正都是各自<code>SSR</code>流程中的一部分,只是具体<code>API</code>不同,原理都是一样的),所以我们只按其中一种介绍,另外一种或者说其他更多的前端框架,你只需要换个名字就可以了. (<code>按图索骥</code>,<code>照猫画虎</code>会哇).<blockquote><span>❝</span><p>&#34;React 水合&#34;（<code>React Hydration</code>）是指将<code>服务器端渲染</code>（<code>Server-Side Rendering</code>，<code>SSR</code>）得到的 <code>HTML 结构</code>与客户端的<code> JavaScript 表现层</code>相结合的过程。</p><span>❞</span></blockquote><p><code>React 水合</code>是在客户端渲染（<code>Client-Side Rendering</code>，<code>CSR</code>）和服务器端渲染之间的一个关键步骤，确保在将服务器渲染的 <code>HTML</code> 呈现给用户之后，<code>React</code> 组件能够在客户端接管并继续工作。<p>以下是 <code>React 水合</code>的详细步骤和背后的原理：<ol><li><section><p><strong>「服务器端渲染（SSR）：」</strong> 在<code>服务器端</code>使用 <code>React</code> 渲染组件，生成一段包含完整组件结构的 <code>HTML</code>。</section><ul><li><section>这段 <code>HTML</code> 可以包含组件的初始状态，这样在首次加载页面时，用户将看到已经有内容呈现在页面上，而不需要等待客户端 <code>JavaScript</code> 加载和执行。</section></ul><li><section><p><strong>「客户端 JavaScript 加载：」</strong> 在浏览器中加载包含 <code>React</code> 应用逻辑的 <code>JavaScript</code> 文件。</section><ul><li><section>这些文件可能包括应用的组件、状态管理逻辑、事件处理等。</section></ul><li><section><p><strong>「水合阶段：」</strong> 一旦客户端 <code>JavaScript</code> 加载完成，<strong>「React 将接管页面」</strong>，开始水合过程。</section><ul><li><section>这意味着 <code>React</code> 会检查服务器端渲染生成的 <code>HTML</code>，并将其与客户端 <code>JavaScript</code> 中的组件逻辑进行匹配。</section></ul><li><section><p><strong>「组件恢复和事件绑定：」</strong> 在水合阶段，<code>React</code> 会将服务器端渲染的 <code>HTML</code> 中的组件恢复到其初始状态，并建立与客户端 <code>JavaScript</code> 中的相应组件的联系。</section><ul><li><section>这包括建立事件绑定、状态同步等。</section></ul><li><section><p><strong>「交互和动态更新：」</strong> 一旦水合完成，<code>React</code> 组件就会变得<strong>「可交互」</strong>。</section><ul><li><section>用户可以与页面进行互动，而客户端 <code>JavaScript</code> 负责处理事件、状态更改等</section><li><section>此后，页面将继续响应用户操作，动态地更新内容，而无需再次从服务器获取完整的 <code>HTML</code>。</section></ul></ol><p><code>React 水合</code>的优势在于它结合了<code>服务器端渲染</code>和<code>客户端渲染</code>的优点，提供了更好的性能和用户体验。<blockquote><span>❝</span><p>通过在首次加载时提供<strong>「一部分已渲染的内容」</strong>，用户可以更快地看到页面，并与之互动。然后，客户端 <code>JavaScript</code> 接管页面，继续处理后续的交互和动态更新。</p><span>❞</span></blockquote><hr><h2><span>Next 简单使用教程</span></h2><p><code>Next.js</code> 是一个基于 <code>React</code> 的框架，用于构建具有服务器端渲染（<code>SSR</code>）和静态网站生成（<code>SSG</code>）功能的应用程序。<code>Next.js</code> 提供了一个<strong>「内置的路由系统」</strong>，称为 <code>Next.js App Router</code>，用于管理应用程序的路由和页面导航。<p>下面是一个简单的介绍和代码示例，展示如何使用 <code>Next.js App Router</code>：<ol><li><section><p><strong>「安装 Next.js：」</strong> 首先，你需要在项目中安装 <code>Next.js</code>。你可以使用 <code>npm</code> 或 <code>yarn</code> 进行安装。<pre><span></span><code>npm install next react react-dom# 或yarn add next react react-dom</code></pre></section><li><section><p><strong>「创建页面：」</strong> 在 <code>Next.js</code> 中，页面是位于 <code>pages</code> 目录下的 <code>React</code> 组件。<strong>「每个页面对应一个 URL 路由」</strong>。<p>在项目根目录下创建 <code>pages</code> 目录，并在其中创建一个名为 <code>index.js</code> 的文件，作为默认页面：<pre><span></span><code>// pages/index.jsfunction HomePage() {  return (    <div>      <h1>前端柒八九</h1>    </div>  );}export default HomePage;</code></pre></section><li><section><p><strong>「导航：」</strong> Next.js App Router 提供了 <code>Link</code> 组件来实现内部页面之间的导航。<pre><span></span><code>// pages/index.jsimport Link from &#39;next/link&#39;;function HomePage() {  return (    <div>      <h1>前端柒八九</h1>      <link href=">        <a>北宸南蓁</a>          </link href="></div>  );}export default HomePage;</code></pre><pre><span></span><code>// pages/about.jsfunction AboutPage() {  return (    <div>      <h1>北宸南蓁</h1>    </div>  );}export default AboutPage;</code></pre></section><li><section><p><strong>「启动开发服务器：」</strong> 在终端中运行以下命令以启动 <code>Next.js</code>开发服务器。<pre><span></span><code>npm run dev# 或yarn dev</code></pre><p>访问 <code>http://localhost:3000</code> 可以看到主页，点击 &#34;北宸南蓁&#34; 链接可以切换到关于页面。</section></ol><p><code>Next.js App Router</code> 简化了页面导航和路由管理，使开发者能够更轻松地创建多页面应用。使用 <code>Link</code> 组件可以实现内部页面之间的无刷新切换，而无需重新加载整个页面。这对于提供更好的用户体验非常有帮助。<hr><h1><span>2. React :客户端UI库</span></h1><p>自诞生以来，<code>React</code> 一直是一个<strong>「客户端UI库」</strong>。它是一个<code>基于JavaScript的开源库</code>，帮助Web和移动开发者构建采用<code>组件化架构</code>的应用程序。<p><code>React</code>的哲学建议我们将整个设计拆分成更小、自包含的组件，称为<code>组件</code>(<code>components</code>)。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/2d28348f.webp><figcaption>一个组件被拆分为多个子组件</figcaption></figure><p>然后，这些组件可以拥有自己的<code>私有数据</code>，称为<code>状态</code>（<code>state</code>），以及在其他组件之间传递数据的方式，称为<code>属性</code>（<code>props</code>）。我们将这些组件分解为一个组件层次结构，定义状态，管理改变状态的效果，并决定数据的流动。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/ae61e6d3.webp><figcaption>state 和 props 流动示意图</figcaption></figure><blockquote><span>❝</span><p>所有<code>React</code>组件都是<code>JavaScript</code>函数。</p><span>❞</span></blockquote><p>当应用程序在浏览器上加载时，我们下载组件代码并使用它们使应用程序正常运行。<hr><h1><span>3. 传统 React 应用的通病</span></h1><p><code>React客户端组件</code>在解决特定用例方面表现良好。但是，在有些场景下,它表现的<strong>「差强人意」</strong>.<p>现在让我们看一下我们可能会遇到的一些常见问题示例。<h2><span>布局抖动</span></h2><p>一个非常常见的用户体验问题是组件渲染时突然的布局变化。<pre><span></span><code>const App = () =&gt; {    return (        <wrapper>            <componenta >            <componentb >        </componentb ></componenta ></wrapper>    )}</code></pre><p>我们有两个组件，<code>ComponentA</code> 和 <code>ComponentB</code>，它们作为<code>子组件</code>传递给一个 <code>Wrapper</code> 组件。<p>每个组件的主体看起来类似于这样：<h3><span>Wrapper 组件</span></h3><pre><span></span><code>const Wrapper = ({children}) =&gt; {    const [wrapperData, setWrapperData] = useState({});    useEffect(() =&gt; {    // 模拟异步接口    getWrapperData().then(res =&gt; {      setWrapperData(res.data);    });  }, []);    // 只有异步接口,成功返回,才开始渲染子组件(通过children)  return (   &lt;&gt;      <h1>{wrapperData.name}</h1>      &lt;&gt;        {wrapperData.name &amp;&amp; children}            )}</code></pre><h3><span>ComponentA组件</span></h3><pre><span></span><code>const ComponentA = () =&gt; {  const [componentAData, setComponentAData] = useState({});    useEffect(() =&gt; {    getComponentAData().then(res =&gt; {      setComponentAData(res.data);    });  }, []);    return (   &lt;&gt;      <h1>{componentAData.name}</h1>      )}</code></pre><h3><span>ComponentB组件</span></h3><pre><span></span><code>const ComponentB = () =&gt; {  const [componentBData, setComponentBData] = useState({});    useEffect(() =&gt; {    getComponentBData().then(res =&gt; {      setComponentBData(res.data);    });  }, []);    return (   &lt;&gt;      <h1>{componentBData.name}</h1>      )}</code></pre><p><strong>「每个组件都负责获取自己的数据」</strong>。因此，每个组件都不受其他组件数据的干扰。这种情况,貌似很<code>玩美</code>. (<code>徐志胜语音包</code>)<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/3cb8e30b.gif></figure><p>但是,如果遇到下面的情况,阁下该如何应对呢. 让我们慢慢道来.<p>假设从每个组件发起的 API 调用获取响应的时间如下：<ul><li><section><code>&lt;Wrapper /&gt;</code> 获取响应需要 <code>1 秒</code></section><li><section><code>&lt;ComponentB /&gt;</code> 获取响应需要 <code>2 秒</code></section><li><section><code>&lt;ComponentA /&gt;</code> 获取响应需要 <code>3 秒</code></section></ul><p>这里就会出现很<strong>「匪夷所思」</strong>的场景<ul><li><section><code>Wrapper</code> 在 1 秒后对用户可见。</section><li><section>然后 <code>ComponentB</code> 在 2 秒后出现。</section><li><section>经过 3 秒，<code>ComponentA</code> 出现。但是 <code>ComponentA</code> 的出现会将 <code>ComponentB</code> 推下去，就好像 <code>ComponentA</code> 突然冒出来一样。这不是很好的用户体验。</section></ul><p>从网上找了一个类似的效果,大家可以不必要特意强调组件名称的异同.只看对应的效果即可.<p><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/56bd58c8.gif><p>这就是我们常说的页面抖动,而这个情况,又会产生<code>布局位移</code>。 导致网页<strong>「视觉稳定性」</strong>很差. 如果想了解更过,可以查看我们之前写的<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU2OTE1Mw==&amp;mid=2247489275&amp;idx=1&amp;sn=783fd13d187421392d576c36a25abb1b&amp;scene=21#wechat_redirect">CLS</a>.<p>当然,我们可以通过使用<code>加载指示器</code>或<code>闪烁效果</code>来改善体验，告诉用户稍后会有一些内容出现。但是,这个效果(自认为)是一种<strong>「掩耳盗铃」</strong>的方式.<hr><h2><span>网络瀑布流</span></h2><p>另一个问题是，子组件（<code>ComponentA</code> 和 <code>ComponentB</code>）甚至在 <code>Wrapper</code> 组件从其所发起的 API 调用获取响应之前都没有被渲染出来，这导致了一个<code>瀑布效应</code>(<code>Waterfall</code>)。连续的数据获取总是会引入<code>瀑布效应</code>。<p>在我们的示例中，只有在 <code>Wrapper</code> 组件中的 API 调用获取响应之后，其他两个组件才会被渲染出来。<hr><h2><span>可维护性问题</span></h2><p>我们如何解决<strong>「瀑布问题」</strong>呢？<p>现在假设我们的任何组件都不进行任何网络调用。我们<strong>「一次性使用」</strong>单个API调用<code>fetchAllDetails()</code>获取所有组件的详细信息，包括父组件在内。<p>之后，我们将所需的信息作为<code>props</code>传递给每个组件。这种处理方式,<strong>「或多或少」</strong>可以减少<strong>「瀑布问题」</strong><pre><span></span><code>const App = () =&gt; {    // 假设,该网络调用在合适的地方进行调用(`useEffect`等)    const info = fetchAllDetails();        return(     <wrapper ino={info.wrapperinfo} >        <componenta ino={info.ainfo} >        <componentb ino={info.binfo} >               )}</componentb ino={info.binfo} ></componenta ino={info.ainfo} ></wrapper ino={info.wrapperinfo} ></code></pre><p>这种方法并没有什么问题。但是，<strong>「API 的响应与我们的组件之间耦合度很高」</strong>。这可能会导致一些<code>可维护性</code>问题。<p>假设有一天，<strong>「善变小可爱」</strong>产品决定放弃<code>ComponentA</code>功能。那么我们可以简单地去掉上面代码中的<code>ComponentA</code>组件。这没问题！我们还希望从 API 响应中删除 <code>AInfo</code>，因为我们不想处理组件未使用的数据。毕竟，如果没有 <code>ComponentA</code>，那就不需要 <code>AInfo</code>。<hr><h2><span>性能成本</span></h2><p>我们将要讨论的最后一个问题领域是<code>性能成本</code>。<img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/1e22203e.webp><p>上图形象的描绘了<code>JavaScript</code>对客户端带来的负担<blockquote><span>❝</span><p><code>React</code>组件是客户端<code>JavaScript</code>函数。它们是我们的<code>React</code>应用程序的构建块。当我们在客户端加载应用程序时，组件会下载到客户端，<code>React</code>会执行必要的操作来为我们渲染它们。</p><span>❞</span></blockquote><p>但是这会带来两个重要问题：<p>首先，当用户发送请求时，应用程序会下载<code>HTML</code>以及链接的<code>JavaScript</code>、<code>CSS</code>和其他资产，如<code>Image</code>。<p>在客户端（浏览器上），<code>React</code>开始执行其魔法，并进行<code>HTML</code>结构的<code>水合</code>(<code>hydrates</code>)。它解析<code>HTML</code>，将事件侦听器附加到<code>DOM</code>，并从存储中获取数据。因此，该站点变成了一个完全操作的React应用程序。<p>但问题是，客户端上会发生很多事情。我们最终会将<strong>「所有这些代码」</strong>都下载到客户端。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/e59fa1ca.webp><figcaption>浏览器上下载的脚本数量</figcaption></figure><p>通常情况下，我们需要将外部库（Node模块）作为项目的依赖项。所有这些依赖项都会在客户端上下载，使其变得更加臃肿。<hr><h1><span>SSR 和 Suspense 解决的痛点</span></h1><p>为了更好地理解对 <code>RSC</code> 的需求，首先需要理解对服务器端渲染（<code>SSR</code>）和 <code>Suspense</code> 的需求。<p><code>SSR</code> 关注初始页面加载，将预渲染的 <code>HTML</code> 发送到客户端，然后在它被下载的 <code>JavaScript</code> 注入后，才会表现为典型的 <code>React</code> 应用程序行为。<code>SSR</code> 也<strong>「仅发生一次：在直接导航到页面时」</strong>。<p>仅仅使用 <code>SSR</code>，用户可以更快地获取 <code>HTML</code>，但必须在<code>all or nothing</code>的瀑布流之前等待，然后才能与 <code>JavaScript</code> 进行交互：<ul><li><section>必须从服务器获取所有数据，然后才能显示其中的任何内容。</section><li><section>必须从服务器下载所有 <code>JavaScript</code>，然后才能将客户端注入其中。</section><li><section>必须在客户端上完成所有的注入，然后才能与任何内容进行交互。</section></ul><p>为了解决这个问题，<code>React</code> 创建了 <code>Suspense</code>，它允许在服务器端进行 <code>HTML</code> 流式传输，并在客户端上进行选择性的注入。通过将组件包装在 <code>&lt;Suspense&gt;</code> 中，我们可以<strong>「告诉服务器将该组件的渲染和注入降低优先级，让其他组件在不受较重组件阻塞的情况下加载」</strong>。<p>当我们在 <code>&lt;Suspense&gt;</code> 中有多个组件时，<code>React</code> 会按照我们编写的顺序<strong>「从上往下处理树状结构」</strong>，使我们的应用程序能够进行最优化的流式传输。然而，如果用户尝试与某个特定组件进行交互，该组件将优先于其他组件。<p>这大大改善了情况，但仍然存在一些问题：<ul><li><section>在显示任何组件之前，必须从服务器获取整个页面的数据。唯一的方法是在 <code>useEffect()</code> 钩子中在客户端进行数据获取，这比服务器端获取需要更长的往返时间，并且仅在组件渲染和注入后才发生。</section><li><section>所有页面的 <code>JavaScript</code> 最终都会被下载，即使它以异步方式流式传输到浏览器。随着应用程序的复杂性增加，用户下载的代码量也会增加。</section><li><section>尽管优化了注入，用户仍然无法与组件进行交互，直到客户端的 <code>JavaScript</code> 被下载并且为该组件实现。</section><li><section>大部分 <code>JavaScript</code> 计算负荷仍然位于客户端，可能在各种不同类型的设备上运行。</section></ul><figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/0b44ec2e.webp></figure><hr><p>通过上面的各种举证和分析,我们或多或少的知道,<code>React</code>在平时开发中遇到的一些令人<strong>「深恶痛绝」</strong>的问题. 其实<code>React</code>官方也知道这些问题,所以提出了<code>RSC</code>.<p>但在我们谈论这些之前，让我们更多地了解一下<code>客户端</code>和<code>服务器</code>。<hr><h1><span>4. 客户端-服务器模型</span></h1><p>在本文中，我们已经多次使用了<code>“客户端”</code>和<code>“服务器”</code>这两个术语。让我们<strong>「高屋建瓴」</strong>的解释它们之间的关系<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/e11af050.webp><figcaption>客户端与服务器之间的关系</figcaption></figure><ul><li><section><p>客户端：在应用程序方面，客户端是在最终用户端执行任务的系统。客户端包括我们的台式电脑、笔记本电脑、移动设备、浏览器等。</section><li><section><p>服务器：<code>字如其人</code>，服务器为客户端提供服务。它可以与数据存储或数据库共存，以便快速访问数据。</section><li><section><p>请求：请求是客户端用于向服务器请求服务的通信方式。</section><li><section><p>响应：响应也是服务器用于将服务（数据/信息）发送回客户端的通信方式。</section></ul><p>如果想了解更多关于网络相关的东西,可以参考之前写的<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3NjU2OTE1Mw==&amp;action=getalbum&amp;album_id=2328290719121178625#wechat_redirect">网络篇</a><hr><p>在服务器组件出现之前，我们编写的<code>所有 React 代码</code>都是在客户端（浏览器）上进行渲染的。因此，为了与在服务器上进行渲染的服务器组件区分开来，从现在开始，我们将常规的 React 组件（其中使用状态、<code>effect</code>、仅限于浏览器的 API 等）称为<code>客户端组件</code>(<code>Client Components</code>)。<h2><span>React Client Components</span></h2><p>传统上<code>React</code>组件存在于客户端。当它们与服务器交互时，它们发送请求并等待响应返回。在接收到响应后，客户端触发下一组操作。<p>如果请求的服务成功完成，客户端组件将根据UI采取相应操作，并显示成功消息。如果出现错误，客户端组件会向用户报告错误信息。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/31a4ddb2.webp></figure><p>当它引起网络瀑布问题时，客户端组件的响应被延迟，从而导致糟糕的用户体验。<hr><h2><span>React Server Components</span></h2><p>我们可以将<code>React</code>组件迁移到服务器上.也就是说我们可以将它们与后台数据一起放置.<p>让我们现在来了解一下<code>RSC</code>。这些新的组件可以<strong>「更快地获取数据」</strong>，因为它们位于服务器上。它们可以访问我们的服务器基础设施，如<code>文件系统</code>和<code>数据存储</code>，而<strong>「无需通过网络进行任何往返」</strong>。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/4956945f.webp></figure><p>对于React开发者来说，这是一个完整的范式转变，因为现在我们必须<strong>「从服务器组件的角度来思考」</strong>。<blockquote><span>❝</span><p>使用<code>RSC</code>，我们可以将数据获取逻辑移至服务器（使我们的组件无需网络调用即可获取数据），并在服务器上准备好它。返回到客户端的数据是一个精心构造的组件，其中包含了所有的数据。</p><span>❞</span></blockquote><p>这意味着使用<code>RSC</code>，我们可以编写如下的代码：<pre><span></span><code>import { dbConnect } from &#39;@/services/mongo&#39;import { addCourseToDB } from &#39;./actions/add-course&#39;import CourseList from &#39;./components/CourseList&#39;export default async function App() {  // 建立 MongoDB 链接  await dbConnect();    // 从数据库(db)中获取对应的数据信息  const allCourses = await courses.find();    // 数据校验(查看是否成功和数据格式)  console.log({allCourses})  return (    <main>      <div>        <courselist allcourses={allcourses} >        </courselist allcourses={allcourses} ></div>    </main>  )}</code></pre><p>从上面的代码中我们可以注意到一些写法上的变化<ul><li><section>组件的类型是<code>async</code>，因为它将处理异步调用。</section><li><section>我们从组件本身连接到数据库（<code>MongoDB</code>）。</section><ul><li><section>在常规的开发中,我们只有在<code>Node.js</code>或<code>Express中</code>才会看到这种代码</section></ul><li><section>然后我们查询数据库并获取数据，以便将其传递给我们的JSX进行渲染。</section><li><section>注意，<code>控制台日志</code>会在服务器控制台上记录，而不是在我们的浏览器控制台上。</section></ul><p>另外，我们完全摆脱了状态管理（<code>useState</code>）和副作用管理（<code>useEffect</code>）。<p>使用<code>RSC</code>，我们可能不需要使用<code>useEffect</code>（<code>老死不相往来</code>的那种）。<hr><h1><span>6. RSC的红与黑</span></h1><p>以下是关于<code>RSC</code>可以做和不能做的事情的列表。尽管服务器组件可能看起来很高级，但并不意味着我们可以在任何地方都使用它们。<h2><span>可以做的事情：</span></h2><ul><li><section>使用 <code>async/await</code> 与仅限于服务器的数据源，如<code>数据库</code>、<code>内部服务</code>、<code>文件系统</code>等进行数据获取。</section><li><section>渲染其他服务器组件、本地元素（如 <code>div</code>、<code>span</code> 等）或客户端组件（普通的 React 组件）。</section></ul><h2><span>不能做的事情：</span></h2><ul><li><section>无法使用 <code>React</code> 提供的钩子，比如 <code>useState</code>、<code>useReducer</code>、<code>useEffect</code> 等，因为服务器组件是在服务器上渲染的。</section><li><section>不能使用<code>浏览器 API</code>，比如本地存储等（不过在服务器上可以进行 <code>polyfill</code>）。</section><li><section>不能使用依赖于仅限于浏览器 API（例如本地存储）或依赖于状态或效果的自定义钩子的任何实用函数。</section></ul><hr><h1><span>7. 如何同时使用客户端组件和服务器组件</span></h1><blockquote><span>❝</span><p>我们的应用程序可以是服务器组件和客户端组件的组合。</p><span>❞</span></blockquote><p><code>服务器组件</code>可以导入并渲染客户端组件，但客户端组件不能在其中渲染服务器组件。如果我们想在客户端组件中使用服务器组件，我们可以将其作为<code>props</code>传递并以这种方式使用。<blockquote><span>❝</span><p>最好将服务器组件放在组件层次结构的<strong>「根部」</strong>，并将客户端组件推向组件树的<strong>「叶子」</strong>。</p><span>❞</span></blockquote><p>数据获取可以在服务器组件的顶部进行，并可以按照<code>React</code>允许的方式进行传递。用户交互（事件处理程序）和访问浏览器API可以在客户端组件中的叶子级别进行处理。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/f8f5b849.webp></figure><p><code>客户端组件</code>无法导入服务器组件，但反过来是可以的。在<code>服务器组件</code>内部导入客户端组件或服务器组件都是可以的。而且，服务器组件可以将另一个服务器组件作为子组件传递给客户端组件，例如：<pre><span></span><code>const ServerComponentA = () =&gt; {    return (        <clientcomponent>            <servercomponentb >        </servercomponentb ></clientcomponent>    )}</code></pre><p>在上面的示例中，我们将一个名为 <code>ServerComponentB</code> 的服务器组件作为子组件传递给了客户端组件。<blockquote><span>❝</span><p>让我们总结一下：<ul><li><section>可以在服务器组件内部导入客户端组件。</section><li><section>不能在客户端组件内部导入服务器组件。</section><li><section>可以将一个服务器组件作为子组件传递给服务器组件内的客户端组件。</section></ul><span>❞</span></blockquote><hr><h2><span>RSC vs SSR</span></h2><p><code>RSC</code>和<code>SSR</code>两者的名字都包含了<code>Server</code>这个词，但相似之处仅限于此。<p>通过<code>SSR</code>，我们将原始<code>HTML</code>从服务器发送到客户端，然后所有客户端的<code>JavaScript</code>都被下载。<code>React</code>开始<code>水合</code>化过程，将<code>HTML</code>转换为可交互的<code>React</code>组件。在<code>SSR</code>中，<strong>「组件不会留在服务器上」</strong>。<p>而使用<code>RSC</code>，<strong>「组件会留在服务器上」</strong>，并且可以访问服务器基础设施，而无需进行任何网络往返。<p><code>SSR</code>用于加快应用程序的<strong>「初始页面加载速度」</strong>。我们可以在应用程序中同时使用<code>SSR</code>和<code>RSC</code>，而不会出现任何问题。<hr><h1><span>8. RSC的优点</span></h1><h2><span>零捆绑包大小的组件</span></h2><p>使用库对开发人员很有帮助，但它会增加捆绑包的大小，可能会影响应用程序性能。<p>应用程序的许多部分并不是交互式的，也不需要完全的数据一致性。例如，<code>详细信息</code>页面通常显示有关产品、用户或其他实体的信息，不需要根据用户交互来更新。<blockquote><span>❝</span><p><code>RSC</code>允许开发人员在<strong>「服务器上渲染静态内容」</strong>。我们可以自由地在服务器组件中使用第三方包，而不会对捆绑包大小产生任何影响。</p><span>❞</span></blockquote><h3><span>常规组件</span></h3><pre><span></span><code>import marked from &#39;marked&#39;; // 35.9K (11.2K gzipped)import sanitizeHtml from &#39;sanitize-html&#39;; // 206K (63.3K gzipped)function NoteWithMarkdown({text}) {  const html = sanitizeHtml(marked(text));  return (/* render */);}</code></pre><p>如果我们将上面的示例渲染为<code>RSC</code>，我们可以使用完全相同的代码来实现我们的功能，<strong>「但避免将其发送到客户端」</strong> - 这将节省超过 240K 的代码（未压缩）。<h3><span>Server Component (零捆绑包大小)</span></h3><pre><span></span><code>import marked from &#39;marked&#39;; // 零捆绑包import sanitizeHtml from &#39;sanitize-html&#39;; // 零捆绑包function NoteWithMarkdown({text}) {  // ....}</code></pre><blockquote><span>❝</span><p>简而言之，如果我们在服务器组件内使用任何第三方库，该库将不会包含在客户端的捆绑包中。这将减小 JavaScript 捆绑包的大小。</p><span>❞</span></blockquote><p>换句话说，通过服务器组件，初始页面加载更快，更精简。基本的客户端运行时是可缓存的，并且<strong>「大小是可预测的，不会随着应用程序的增长而增加」</strong>。额外的面向用户的 JavaScript 主要是在我们的应用程序通过客户端组件需要更多的客户端交互时添加的。<p>如果我们在任何客户端组件内部使用该库，那么就如我们所想，该库将包含在客户端捆绑包中，并将被浏览器下载以进行解析和执行。<hr><h2><span>全权访问后端数据</span></h2><p>正如前面所讨论的，服务器组件可以利用直接的后端访问来使用数据库、内部（微）服务和其他仅限于后端的数据源。<pre><span></span><code>import db from &#39;db&#39;;async function Note({id}) {  const note = await db.notes.get(id);  return <notewithmarkdown note={note} >;}</notewithmarkdown note={note} ></code></pre><p>在上面的代码片段中，我们将 <code>note</code> 传递给了 <code>NoteWithMarkdown</code> 组件。我们可以直接从数据库中获取这个<code>note</code>.<p>如果我们仔细查看代码，我们会发现我们没有进行任何获取 API 调用来获取 <code>note</code>。相反，我们只是在 <code>Note</code> 组件内直接执行了 <code>DB</code> 查询（通常我们在服务器端代码中执行 DB 查询）。这是可能的，因为这是一个服务器组件，它在服务器上进行渲染。<p>让我们再看一个例子，其中我们可以从服务器的服务器组件中访问<code>文件系统</code>：<pre><span></span><code>import fs from &#39;fs&#39;;async function Note({id}) {  const note = JSON.parse(await fs.readFile(`${id}.json`));  return <notewithmarkdown note={note} >;}</notewithmarkdown note={note} ></code></pre><p>正如我们在上面的代码中所看到的，我们使用了 <code>fs</code> 模块（文件系统的缩写）来读取服务器上存在的文件。<hr><h2><span>自动代码分割</span></h2><blockquote><span>❝</span><p>服务器组件将所有对客户端组件的导入视为潜在的代码分割点。</p><span>❞</span></blockquote><p>有如下的<code>SRC</code><pre><span></span><code>import OldPhotoRenderer from &#39;./OldPhotoRenderer.js&#39;;import NewPhotoRenderer from &#39;./NewPhotoRenderer.js&#39;;function Photo(props) {  // 根据业务进行组件的渲染  if (FeatureFlags.useNewPhotoRenderer) {    return <newphotorenderer {...props} >;  } else {    return <oldphotorenderer {...props} >;  }}</oldphotorenderer {...props} ></newphotorenderer {...props} ></code></pre><p>在上面的示例中，我们有两个组件 <code>NewPhotoRenderer</code> 和 <code>OldPhotoRenderer</code>（两者都是客户端组件），它们是有条件地进行渲染的。<p>假设 <code>if (FeatureFlags.useNewPhotoRenderer)</code> 值为 <code>True</code>，那么用户将会看到 <code>NewPhotoRenderer</code> 组件。只有该组件会被发送到客户端（或浏览器）。<code>OldPhotoRenderer</code> 将被懒加载（也就是说，它不会立即被发送到客户端）。因此，只有与用户可见的组件相关的 JavaScript 是需要的。<hr><h2><span>没有瀑布效应</span></h2><p>正如前面讨论过的，连续的数据获取会引入瀑布效应。我们希望找到一种方法来避免从客户端到服务器的连续往返延迟（也就是说，我们必须等待一个请求完成，而请求可能需要一些时间来完成，因为它必须从客户端传输到服务器）。<pre><span></span><code>async function Note(props) {  // NOTE: 在渲染期间加载，在服务器上进行低延迟数据访问  const note = await db.notes.get(props.id);  if (note == null) {    // 处理note 未被获取的逻辑  }  return (/* 根据note 渲染相关页面*/);}</code></pre><p>服务器组件通过将连续的往返请求移到服务器上，使应用程序能够实现这一目标（即不再有从客户端到服务器的获取调用）。<p>问题实际上并不是往返请求本身，而是这些请求是从客户端到服务器的。通过将这个逻辑移到服务器上，我们减少了请求的延迟，提高了性能。<hr><h2><span>服务器组件与客户端代码完全兼容</span></h2><p>服务器组件与客户端代码完全兼容，这意味着客户端组件和服务器组件可以在同一个 React 树中进行渲染。通过将大部分应用程序代码移到服务器上，服务器组件有助于防止客户端数据获取的瀑布效应，快速解决服务器端的数据依赖关系。<p>在传统的客户端渲染中，组件使用 React <code>Suspense</code> 来<code>“暂停”</code>其渲染过程（并显示回退状态），同时等待异步工作完成。通过服务器组件，数据获取和渲染都在服务器上进行，因此 <code>Suspense</code> 也会在服务器端管理等待期，从而缩短总的往返时间，加快回退和完成页面的渲染。<p>需要注意的是，客户端组件在初始加载时仍然进行服务器端渲染（<code>SSR</code>）。<strong>「服务器组件模型并不取代 SSR 或 Suspense，而是与它们一起工作，根据需要为用户提供应用程序的所有部分」</strong>。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/29463059.webp></figure><blockquote><span>❝</span><p>在使用<code> Next.js</code> 和 <code>React</code> 服务器组件时，数据获取和 UI 渲染可以在同一个组件中完成。此外，服务器操作（Server Actions）为用户提供了在页面上的 <code>JavaScript</code> 加载之前与服务器端数据进行交互的方式。</p><span>❞</span></blockquote><hr><h1><span>9. 如何使用Next.js和MongoDB构建课程列表页面</span></h1><p>现在让我们用<code>Next.js</code>构建一个使用<code>RSC</code>的应用程序。<p>因此，我们现在将构建一个课程列表页面，以展示我们如何在<code>Next.js</code>中创建服务器组件，以及它与客户端组件的不同之处。<blockquote><span>❝</span><p>请注意，我们不会在这里深入学习<code>Next.js</code>或<code>MongoDB</code>。我们只是将这个应用程序作为一个示例，来教我们<code>RSC</code>的工作原理以及它们与客户端组件的区别。</p><span>❞</span></blockquote><p>首先，让我们将课程数据添加到数据存储中。对于这个应用程序，我使用了<code>MongoDB</code>。下面的图像显示添加了三个课程的三个文档。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/aed8cb3c.webp></figure><p>接下来，我们将创建一个实用函数来建立与<code>MongoDB</code>的连接。这是一个通用的代码，我们可以在任何基于<code>JavaScript</code>的项目中使用它，以使用<code>Mongoose</code>和<code>MongoDB URI</code>连接到<code>MongoDB</code><pre><span></span><code>import mongoose from &#34;mongoose&#34;;export async function dbConnect(): Promise<any> {  try {    const conn = await mongoose.connect(String(process.env.MONGO_DB_URI));    console.log(`Database connected : ${conn.connection.host}`);    return conn;  } catch (err) {    console.error(err);  }}</any></code></pre><p>现在，我们需要创建与<code>MongoDB</code>文档相对应的<code>模型</code>(<code>modal</code>)。由于我们处理的是课程数据，这是与之对应的模型：<pre><span></span><code>import mongoose, { Schema } from &#34;mongoose&#34;;const schema = new Schema({  name: {      required: true,      type: String  },  description: {      required: true,      type: String  },  cover: {    required: true,    type: String  },  rating: {    required: true,    type: Number  },  price: {    required: true,    type: Number  },  createdOn: {    type: { type: Date, default: Date.now }  },  link: {    required: true,    type: String  },  type: {    required: true,    type: String  },  comments: {    required: false,    type: [{ body: String, date: Date }]  }});export const courses = mongoose.models.course ?? mongoose.model(&#34;course&#34;, schema);</code></pre><blockquote><span>❝</span><p>通过<code>Next.js App Router</code>，所有的<strong>「组件默认都是服务器组件」</strong>。这意味着它们位于靠近服务器的位置，并且可以访问我们的服务器生态系统。</p><span>❞</span></blockquote><p>下面的代码是一个常规的<code>Next.js</code>组件，但具有一个特殊功能：我们可以<strong>「在组件中直接获取数据库连接，并直接查询数据，而无需经过任何状态和效果管理」</strong>。<p>从该组件中记录的任何内容都不会被记录到我们的浏览器控制台，因为这是一个服务器组件。我们可以在服务器控制台中查看日志（我们可以使用<code>yarn dev</code>命令启动服务器的终端）。<p>由于<strong>「与数据库的交互是异步的」</strong>，我们在进行调用时使用<code>await</code>关键字，并在组件上使用<code>async</code>关键字。在接收到响应后，我们将其作为属性传递给子组件。<pre><span></span><code>import { dbConnect } from &#39;@/services/mongo&#39;import { courses } from &#39;@/models/courseModel&#39;import { addCourseToDB } from &#39;./actions/add-course&#39;import AddCourse from &#39;./components/AddCourse&#39;import CourseList from &#39;./components/CourseList&#39;export default async function Home() {  // 建立MongoDB链接  await dbConnect();    //获取所有的数据信息  const allCourses = await courses.find().select(        [&#34;name&#34;, &#34;cover&#34;, &#34;rating&#34;]);    // 在服务器终端中打印显示数据  console.log({allCourses})  return (    <main>      <div>        <h1>Courses</h1>         <addcourse addcoursetodb={addcoursetodb} >        <courselist allcourses={allcourses} >        </courselist allcourses={allcourses} ></addcourse addcoursetodb={addcoursetodb} ></div>    </main>  )}</code></pre><p>Home组件包含：<ul><li><section>一个标题</section><li><section>一个组件（<code>AddCourse</code>），用于包装一个添加课程的按钮</section><li><section>一个组件（<code>CourseList</code>），用于将课程显示为列表。</section></ul><figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/da7f44b1.webp></figure><p>我们知道，<strong>「服务器组件可以同时渲染客户端和服务器组件」</strong>。<code>AddCourse</code>组件需要用户交互，即用户需要点击按钮来添加课程。所以它不能是服务器组件.<p>因此，让我们为<code>AddCourse</code>创建一个<code>客户端组件</code>。通过<code>Next.js App Router</code>，默认情况下，所有组件都是服务器组件。<blockquote><span>❝</span><p>如果我们想创建一个客户端组件，我们必须在组件顶部（甚至在任何导入语句之前）使用名为<code>use client</code>的指令来明确创建一个客户端组件。</p><span>❞</span></blockquote><h3><span>客户端组件- AddCourse</span></h3><pre><span></span><code>&#39;use client&#39;import { useState } from &#39;react&#39;;import Modal from &#39;./Modal&#39;;import AddCourseForm from &#34;./AddCourseForm&#34;;export default function AddCourse({  addCourseToDB,}: {  addCourseToDB: (data: any) =&gt; Promise<void>}) {  const [showAddModal, setShowAddModal] = useState(false);  const add = async(data: any) =&gt; {    await addCourseToDB(data);    setShowAddModal(false);  }  return (    &lt;&gt;      <button        onclick={() => setShowAddModal(true)}      &gt;        Add Course            <modal         shouldshow={showaddmodal}         body={          <addcourseform             saveaction={add}             cancelaction={() => setShowAddModal(false)} /&gt;} /&gt;      )}</modal         shouldshow={showaddmodal}         body={          <addcourseform             saveaction={add}             cancelaction={() =></button        onclick={() =></void></code></pre><h3><span>服务器组件 -CourseList</span></h3><p><code>CourseList</code>组件不需要任何事件处理程序，因此我们可以将其保持为服务器组件。<pre><span></span><code>import Image from &#39;next/image&#39;import Link from &#39;next/link&#39;export default function CourseList(courseList: any) {  const allCourses = courseList.allCourses;  return(    <div>      {        allCourses.map((course: any) =&gt;        <link key={course['_id']} href={`>          <div>            <image              src={course.cover}              width={200}              height={200}              alt={course.name}            >            <h2>{course.name}</h2>            <p>{course.rating}</p>          </image              src={course.cover}              width={200}              height={200}              alt={course.name}            ></div>                )}    </link key={course['_id']} href={`></div>    )}</code></pre><p>我们打开浏览器开发工具的<code>Sources</code>选项卡，以确定客户端上下载了什么，服务器上留下了什么。我们在这里是看不到<code>page.tsx</code>文件或<code>CourseList.tsx</code>文件信息。这是因为这些是<strong>「服务器组件，它们永远不会成为我们的客户端捆绑包的一部分」</strong>。<p>我们只会看到我们在应用程序中明确<strong>「标记为客户端组件」</strong>的组件。<figure><img src=https://note-2019-images.oss-cn-hangzhou.aliyuncs.com/f428fc44.webp></figure><blockquote><span>❝</span><p>在 <code>Next.js App Router</code> 中，所有获取的数据现在默认为静态数据，在构建时渲染。然而，这可以很容易地改变：<code>Next.js</code> 扩展了 <code>fetch</code> 选项对象，以提供缓存和重新验证规则的灵活性。<br>我们可以使用 <code>{next: {revalidate: number}}</code> 选项以设置的时间间隔或在后端更改发生时刷新静态数据（增量静态再生成），而 <code>{cache: &#39;no-store&#39;}</code> 选项可以在动态数据的 <code>fetch</code> 请求中传递（服务器端渲染）。</p><span>❞</span></blockquote><hr><h1><span>总结</span></h1><p>总结一下：<ul><li><section><code>React</code>服务器组件具有后端访问权限，无需进行任何网络往返。</section><li><section>我们可以通过使用<code>RSC</code>来避免网络瀑布问题。</section><li><section><code>React</code>服务器组件支持<strong>「自动代码拆分」</strong>，并通过零捆绑大小提高应用程序的性能。</section><li><section>由于这些组件位于服务器端，它们无法访问客户端端的事件处理程序、状态和效果。这意味着我们不能使用任何事件处理程序或<code>React</code>钩子，如<code>useState</code>、<code>useReducer</code>和<code>useEffect</code>。</section><li><section><code>React</code>服务器组件可以导入并渲染客户端组件，但反之则不成立。但我们可以将服务器组件作为<code>props</code>传递给客户端组件。</section><li><section><code>RSC</code>并不意味着取代客户端组件。健康的应用程序同时使用服务器组件来进行动态数据获取以及客户端组件来实现丰富的交互性。挑战在于确定何时使用每种组件。</section></ul><hr><h1><span>后记</span></h1><p><strong>「分享是一种态度」</strong>。<p>参考资料：<ol><li><section>understanding-react-server-components</section><li><section>react-server-components-for-beginners/</section><li><section>how-to-use-react-server-components/</section><li><section>what-even-are-react-server-components/</section></ol></section><p><br></div></main>
<hr>
<footer>
        <label>原网址: <a href="https://mp.weixin.qq.com/s/bSV19qdx96Bch_Ryg1pWXA" target="_blank" referrerpolicy="no-referrer" rel="noopener noreferrer">访问</a></label><br/>
        <label>创建时间: 2024-05-08 10:11:42</label><br/>
        <br/>
        
      </footer>
</body>
</html>